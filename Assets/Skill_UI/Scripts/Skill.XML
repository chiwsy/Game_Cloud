<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Skill</name>
    </assembly>
    <members>
        <member name="T:Skill.UI.WrapImage">
            <summary>
            Draw a wrapped texture
            </summary>
        </member>
        <member name="T:Skill.UI.Control">
            <summary>
            Defines base class for all Controls in Skill.UI
            </summary>
        </member>
        <member name="T:Skill.UI.BaseControl">
            <summary>
            Defines base class for all controls
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.OnPositionChanged">
            <summary>
            when position of control changed 
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.OnRenderAreaChanged">
            <summary>
            when RenderArea of control changed
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.OnLayoutChanged">
            <summary>
            when layout of control changed and parent control needs to update layout of it's children
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.OnVisibilityChanged">
            <summary>
            when Visibility of control changed
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.#ctor">
            <summary>
            Create a BaseControl
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.Render">
            <summary> Render control's content </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.BeginRender">
            <summary> Begin Render control's content </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.OnGUI">
            <summary>
            to render control you have to call this method in OnGUI method of MonoBehavior.(call this for Frame class)
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.BringToFront">
            <summary> Attempts to bring this element to front. </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.BringToBack">
            <summary> Attempts to bring this element to back. </summary>
        </member>
        <member name="M:Skill.UI.BaseControl.Containes(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Returns true if the x and y components of mousePosition is inside RenderArea.
            </summary>
            <param name="mousePosition">Mouse position</param>
            <param name="screenOffset">ScreenOffset (specified by RenderParams)</param>
            <returns>true if the x and y components of mousePosition is inside RenderArea, otherwise false</returns>
        </member>
        <member name="M:Skill.UI.BaseControl.Containes(UnityEngine.Vector2)">
            <summary>
            Returns true if the x and y components of point is inside RenderArea.
            </summary>
            <param name="point">Mouse position</param>        
            <returns>true if the x and y components of point is inside RenderArea, otherwise false</returns>
        </member>
        <member name="P:Skill.UI.BaseControl.Position">
            <summary>
            Position of control relative to parent
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.X">
            <summary>
            Gets or sets Position.X
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Y">
            <summary>
            Gets or sets Position.Y
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Width">
            <summary>
            Gets or sets the suggested width of the element
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Height">
            <summary>
            Gets or sets the suggested height of the element.
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.RenderSize">
            <summary> Gets the final render size of this element. </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.LayoutWidth">
            <summary>
            Retrieves Width used in layout. It is dependents on visibility and state of children
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.LayoutHeight">
            <summary>
            Retrieves Height used in layout. It is dependents on visibility and state of children
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.ActualWidth">
            <summary> Gets the rendered width of this element. </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.ActualHeight">
            <summary> Gets the rendered height of this element. </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Margin">
            <summary> Gets or sets the outer margin of an element.</summary>        
            <returns>
            Provides margin values for the element. The default value is a System.Windows.Thickness with all properties equal to 0 (zero).
            </returns>
        </member>
        <member name="P:Skill.UI.BaseControl.RenderArea">
            <summary>
            The area that used to render control.
            </summary>
            <remarks>
            if it is child of Scrollview or Group RenderArea is relative, otherwise it is absolute
            </remarks>
        </member>
        <member name="P:Skill.UI.BaseControl.Parent">
            <summary> Parent Panel that host this control.(do not modify it manually) </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.VerticalAlignment">
            <summary>
            Gets or sets the vertical alignment characteristics applied to this element
            when it is composed within a parent element such as a panel or items control.
            </summary>
            <returns> A vertical alignment setting. The default is VerticalAlignment.Stretch. </returns>
        </member>
        <member name="P:Skill.UI.BaseControl.HorizontalAlignment">
            <summary>
            Gets or sets the horizontal alignment characteristics applied to this element
            when it is composed within a parent element, such as a panel or items control.
            </summary>
            <returns> A horizontal alignment setting, as a value of the enumeration. The default is HorizontalAlignment.Stretch. </returns>
        </member>
        <member name="P:Skill.UI.BaseControl.Name">
            <summary>
            Name of control. (optional)
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Dock">
            <summary>
            Dock of Control when it is a child of DockPanel
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Row">
            <summary>
            Grid.Row when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Column">
            <summary>
            Grid.Column when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.RowSpan">
            <summary>
            Grid.RowSpan when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.ColumnSpan">
            <summary>
            Grid.ColumnSpan when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.Visibility">
            <summary>
            Gets or sets the user interface (UI) visibility of this element.
            </summary>
        </member>
        <member name="E:Skill.UI.BaseControl.PositionChanged">
            <summary> Occurs when position of control changed </summary>
        </member>
        <member name="E:Skill.UI.BaseControl.RenderAreaChanged">
            <summary> Occurs when RenderArea of control changed </summary>
        </member>
        <member name="E:Skill.UI.BaseControl.LayoutChanged">
            <summary> Occurs when layout of control changed and parent control needs to update layout of it's children</summary>
        </member>
        <member name="E:Skill.UI.BaseControl.VisibilityChanged">
            <summary> Occurs when Visibility of control changed </summary>
        </member>
        <member name="P:Skill.UI.BaseControl.ControlType">
            <summary> Specify type of Control  </summary>
        </member>
        <member name="P:Skill.UI.Control.ControlType">
            <summary>
            Type of Control : Control
            </summary>
        </member>
        <member name="P:Skill.UI.Control.Style">
            <summary>
            The style to use. If null, the style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.UI.Control.Focusable">
            <summary>
            Indicates whether the element can receive focus.
            </summary>
        </member>
        <member name="M:Skill.UI.WrapImage.#ctor">
            <summary>
            Create an instance of WrapImage
            </summary>
        </member>
        <member name="M:Skill.UI.WrapImage.Render">
            <summary> Render Image </summary>
        </member>
        <member name="P:Skill.UI.WrapImage.Texture">
            <summary> Texture to display. </summary>
        </member>
        <member name="P:Skill.UI.WrapImage.AlphaBlend">
            <summary> Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display. </summary>
        </member>
        <member name="P:Skill.UI.WrapImage.WrapU">
            <summary> Enable or Disable Wrap U</summary>
        </member>
        <member name="P:Skill.UI.WrapImage.WrapV">
            <summary> Enable or Disable Wrap V</summary>
        </member>
        <member name="T:Skill.UI.TextArea">
            <summary>
            Make a Multi-line text area where the user can edit a string.
            </summary>
        </member>
        <member name="T:Skill.UI.FocusableControl">
            <summary>
            Base class for focusables Controls
            </summary>
        </member>
        <member name="M:Skill.UI.FocusableControl.OnGotFocus">
            <summary>
            when this element gets logical focus.
            </summary>
        </member>
        <member name="M:Skill.UI.FocusableControl.OnLostFocus">
            <summary>
            when this element loses logical focus.
            </summary>
        </member>
        <member name="P:Skill.UI.FocusableControl.Focusable">
            <summary>
            Indicates whether the element can receive focus.
            </summary>
        </member>
        <member name="P:Skill.UI.FocusableControl.IsFocused">
            <summary>
            Gets a value that determines whether this element has logical focus.
            </summary>
            <returns>
            true if this element has logical focus; otherwise, false.
            </returns>
        </member>
        <member name="E:Skill.UI.FocusableControl.GotFocus">
            <summary>
            Occurs when this element gets logical focus.
            </summary>
        </member>
        <member name="E:Skill.UI.FocusableControl.LostFocus">
            <summary>
            Occurs when this element loses logical focus.
            </summary>
        </member>
        <member name="M:Skill.UI.TextArea.OnTextChanged">
            <summary>
            Occurs when text of TextArea changed
            </summary>
        </member>
        <member name="M:Skill.UI.TextArea.#ctor">
            <summary>
            Create an TextArea
            </summary>
        </member>
        <member name="M:Skill.UI.TextArea.Render">
            <summary>
            Render TextArea
            </summary>
        </member>
        <member name="P:Skill.UI.TextArea.Text">
            <summary>
            Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            </summary>
        </member>
        <member name="E:Skill.UI.TextArea.TextChanged">
            <summary>
            Occurs when text of TextArea changed
            </summary>
        </member>
        <member name="P:Skill.UI.TextArea.MaxLength">
            <summary>
            The maximum length of the string. If left out, the user can type for ever and ever.
            </summary>
        </member>
        <member name="T:Skill.UI.Panel">
            <summary>
            Provides a base class for all Panel elements. Use Panel elements to position and arrange child objects
            </summary>
        </member>
        <member name="M:Skill.UI.Panel.RequestUpdateLayout">
            <summary>
            used by inherited objets to request UpdateLayout
            </summary>
        </member>
        <member name="M:Skill.UI.Panel.#ctor">
            <summary>
            Create a panel
            </summary>
        </member>
        <member name="M:Skill.UI.Panel.OnRenderAreaChanged">
            <summary>
            When RenderArea hanged
            </summary>
        </member>
        <member name="M:Skill.UI.Panel.OnLayoutChanged">
            <summary>
            When Layout changed
            </summary>
        </member>
        <member name="M:Skill.UI.Panel.BeginRender">
            <summary>
            Prepare for render
            </summary>
        </member>
        <member name="M:Skill.UI.Panel.Render">
            <summary>
            Render child controls
            </summary>
        </member>
        <member name="M:Skill.UI.Panel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
            <remarks>
            Calling this method has no effect if layout is unchanged, or if neither arrangement nor measurement state of a layout is invalid. 
            However, if layout is invalid in either respect, the UpdateLayout call will redo the entire layout.
            Therefore, you should avoid calling UpdateLayout after each incremental and minor change in the element tree.
            The layout system will perform element layout in a deferred manner, using an algorithm that balances performance and currency, and with a weighting strategy to defer changes to roots until all child elements are valid.
            You should only call UpdateLayout if you absolutely need updated sizes and positions, and only after you are certain that all changes to properties that you control and that may affect layout are completed.
            </remarks>
        </member>
        <member name="M:Skill.UI.Panel.FindControlByName(System.String)">
            <summary>
            Find control in hierarchy with specified name
            </summary>
            <param name="controlName">Name of control to search</param>
            <returns></returns>
        </member>
        <member name="M:Skill.UI.Panel.SetControlRenderArea(Skill.UI.BaseControl,UnityEngine.Rect)">
            <summary>
            calculate RenderArea of Control based on given available Rect
            </summary>
            <param name="c">Control to calc it's RenderArea</param>
            <param name="cellRect">Available space</param>
        </member>
        <member name="P:Skill.UI.Panel.ControlType">
            <summary>  Type of Control : Panel </summary>
        </member>
        <member name="P:Skill.UI.Panel.Padding">
            <summary>
            Gets or sets the padding inside a control.
            </summary>
            <returns>
            The amount of space between the content of a Panel
            and its Margin or Border.
            The default is a thickness of 0 on all four sides.
            </returns>
        </member>
        <member name="P:Skill.UI.Panel.Controls">
            <summary>
            Gets a BaseControlCollection of child elements of this Panel.
            </summary>
        </member>
        <member name="P:Skill.UI.Panel.DesiredSize">
            <summary> The Size needs for all controls </summary>
        </member>
        <member name="P:Skill.UI.Panel.RenderAreaShrinksByPadding">
            <summary>
            Gets RenderArea that shrinks by Padding.
            </summary>
        </member>
        <member name="T:Skill.Controllers.Controller">
            <summary>
            Base class for controllers
            </summary>
        </member>
        <member name="T:Skill.Managers.IEventManagerHooker">
            <summary>
            Generalize using EventManager. if a MonoBehavior wants to use EventManager methods should implement this interface
            </summary>
        </member>
        <member name="M:Skill.Managers.IEventManagerHooker.HookEvents">
            <summary>
            Call this method in Awake and hook desired events of EventManager
            </summary>
        </member>
        <member name="M:Skill.Controllers.Controller.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Controllers.Controller.OnDie(System.Object)">
            <summary>
            When controller dies
            </summary>
            <param name="userData">User data</param>
        </member>
        <member name="M:Skill.Controllers.Controller.OnDestroy">
            <summary>
            when controller destroyed
            </summary>
        </member>
        <member name="M:Skill.Controllers.Controller.Destroy">
            <summary>
            Destroy controller
            </summary>
        </member>
        <member name="M:Skill.Controllers.Controller.HookEvents">
            <summary>
            Hook required events of EventManager
            </summary>
        </member>
        <member name="P:Skill.Controllers.Controller.Behavior">
            <summary>
            BehaviorTree of controller (should provide by subclass)
            </summary>
        </member>
        <member name="P:Skill.Controllers.Controller.Animation">
            <summary>
            AnimationTree of controller (should provide by subclass)
            </summary>
        </member>
        <member name="P:Skill.Controllers.Controller.Posture">
            <summary>
            Current posture of controller
            </summary>
        </member>
        <member name="P:Skill.Controllers.Controller.Spawner">
            <summary>
            Spawner that spawned this controller
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeRandom">
            <summary>
            This blend node allows the Anim Tree to randomly blend between inputs set by the user.
            select random node when BecameRelevant and continue to update that until cease relevant.
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeBlendByIndex">
            <summary>
            Try to keep single child active at time
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeSingleLayer">
            <summary>
            base class for AnimNodes that use single layer for children
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeBlendBase">
            <summary>
            Defiens bass class that have children and manage weights of them
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNode">
            <summary>
            Base class for all AnimNodes in AnimationTree
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimNode.BecameRelevant">
            <summary>
            Occurs when AnimNode became Relevant
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNode.OnBecameRelevant(Skill.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="F:Skill.Animation.AnimNode.CeaseRelevant">
            <summary>
            Occurs when AnimNode cease Relevant
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNode.OnCeaseRelevant(Skill.Animation.AnimationTreeState)">
            <summary>
            call CeaseRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNode.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNode
            </summary>
            <param name="childCount">Number of childrent</param>
        </member>
        <member name="M:Skill.Animation.AnimNode.Update(Skill.Animation.AnimationTreeState)">
            <summary>
            Update AnimationNode
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNode.BeginUpdate(Skill.Animation.AnimationTreeState)">
            <summary>
            Perform pre required actions before update
            </summary>
            <param name="state">State of AnimationTree</param>
            <returns>true if update needed, otherwise false</returns>
        </member>
        <member name="M:Skill.Animation.AnimNode.Blend">
            <summary>
            subclasses override this method to update weight
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNode.SelectLayer(Skill.Animation.AnimationLayerManager,Skill.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Animation.AnimNode.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize and collect information from animationComponent
            </summary>
            <param name="animationComponent">UnityEngine.Animation</param>
        </member>
        <member name="M:Skill.Animation.AnimNode.Destroy">
            <summary>
            Destroy hierarchy of Children
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNode.GetEnumerator">
            <summary>
             Returns an System.Collections.IEnumerator for the children AnimNodes.
            </summary>
            <returns>Returns an System.Collections.IEnumerator for the children AnimNodes.</returns>
        </member>
        <member name="M:Skill.Animation.AnimNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
             Returns an System.Collections.IEnumerator for the children AnimNodes.
            </summary>
            <returns>Returns an System.Collections.IEnumerator for the children AnimNodes.</returns>
        </member>
        <member name="M:Skill.Animation.AnimNode.ToString">
            <summary>
            Represent AnimNode as string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Animation.AnimNode.SetFormat(System.String)">
            <summary>
            update format of all AnimNodeSequences in tree
            </summary>
            <param name="format">Format</param>        
        </member>
        <member name="P:Skill.Animation.AnimNode.Weight">
            <summary>
            Get or set weight of node (0.0f - 1.0f)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.WeightChange">
            <summary>
            Retrieves weight state of node depend on previous frame
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.ChildCount">
            <summary>
            Retrieves number of children
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.Index">
            <summary>
            Index of node in parent children array
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.Parent">
            <summary> parent node</summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.IsRelevant">
            <summary>
            This node is considered 'relevant' - that is, has >0 weight in the final blend.
            </summary> 
        </member>
        <member name="P:Skill.Animation.AnimNode.IsJustBecameRelevant">
            <summary>
            set to true when this node became relevant this round of updates. Will be set to false on the next tick.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.IsJustCeaseRelevant">
            <summary>
            set to true when this node cease relevant this round of updates. Will be set to false on the next tick.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.Name">
            <summary>
            Get of set name of AnimNode
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.CanBlendOutFrom">
            <summary>
            Parent node is requesting a blend out. Give node a chance to delay that.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.CanBlendTo">
            <summary>
            parent node is requesting a blend in. Give node a chance to delay that.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNode.Item(System.Int32)">
            <summary>
            Get or set chilc AnimNodes by index
            </summary>
            <param name="index">Index of child ( 0 - ChildCount )</param>
            <returns>AnimNode at specified index</returns>
        </member>
        <member name="P:Skill.Animation.AnimNode.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNode._ChildrenEnumerator">
            <summary>
            custom enumerator to enumerate children of AnimNode
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendBase.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeBlendBase
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendBase.Blend">
            <summary>
            Blend between children
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendBase.CalcBlendWeights(System.Single[]@)">
            <summary>
            subclasses should implement this and provide valid weight (0.0 - 0.1) for each child 
            </summary>
            <param name="blendWeights"></param>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBase.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBase.BlendTime">
            <summary>
            How long to take to get to the blend target.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBase.BlendRate">
            <summary>
            calculate blend base on deltatime
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeSingleLayer.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeSingleLayer
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeSingleLayer.SelectLayer(Skill.Animation.AnimationLayerManager,Skill.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendByIndex.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeBlendByIndex
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendByIndex.CalcBlendWeights(System.Single[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIndex.SelectedChildIndex">
            <summary>
            Get or set selected child by index
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIndex.SelectedChildName">
            <summary>
            Get or set selected child by name
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIndex.SelectedChildNode">
            <summary>
            Retrives selected child node
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIndex.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeRandom.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeRandom
            </summary>
            <param name="childCoun">number of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeRandom.OnBecameRelevant(Skill.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeRandom.PickRandomChildIndex">
            <summary>
            Select a child index based i\on there chances
            </summary>
            <returns></returns>
        </member>
        <member name="P:Skill.Animation.AnimNodeRandom.Chances">
            <summary>
            Get or set chance of each node. (make sure chances be >0)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeRandom.TotalChance">
            <summary>
            Sum of all chances
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeAimOffsetProfile">
            <summary>
            Represent data required for AnimNodeAimOffset profile 
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffsetProfile.Name">
            <summary> Name of Profile </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffsetProfile.#ctor">
            <summary>
            Create an instance of AnimNodeAimOffsetProfile
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.Item(System.Int32)">
            <summary>
            Retrieves AnimNodeSequence by index
            </summary>
            <param name="index">Zero based index between 0 - 9</param>
            <returns>AnimNodeSequence</returns>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.CenterCenter">
            <summary> AnimationName of CenterCenter child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.CenterUp">
            <summary> AnimationName of CenterUp child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.CenterDown">
            <summary> AnimationName of CenterDown child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.LeftCenter">
            <summary> AnimationName of LeftCenter child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.LeftUp">
            <summary> AnimationName of LeftUp child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.LeftDown">
            <summary> AnimationName of LeftDown child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.RightCenter">
            <summary> AnimationName of RightCenter child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.RightUp">
            <summary> AnimationName of RightUp child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.RightDown">
            <summary> AnimationName of RightDown child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.CenterCenterMTs">
            <summary> MixingTransforms of CenterCenter child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.CenterUpMTs">
            <summary> MixingTransforms of CenterUp child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.CenterDownMTs">
            <summary> MixingTransforms of CenterDown child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.LeftCenterMTs">
            <summary> MixingTransforms of LeftCenter child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.LeftUpMTs">
            <summary> MixingTransforms of LeftUp child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.LeftDownMTs">
            <summary> MixingTransforms of LeftDown child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.RightCenterMTs">
            <summary> MixingTransforms of RightCenter child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.RightUpMTs">
            <summary> MixingTransforms of RightUp child</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffsetProfile.RightDownMTs">
            <summary> MixingTransforms of RightDown child</summary>
        </member>
        <member name="T:Skill.UI.HorizontalAlignment">
            <summary>
            Indicates where an element should be displayed on the horizontal axis relative to the allocated layout slot of the parent element.    
            </summary>
        </member>
        <member name="F:Skill.UI.HorizontalAlignment.Left">
            <summary>
            An element aligned to the left of the layout slot for the parent element.
            </summary>
        </member>
        <member name="F:Skill.UI.HorizontalAlignment.Center">
            <summary>
            An element aligned to the center of the layout slot for the parent element.
            </summary>
        </member>
        <member name="F:Skill.UI.HorizontalAlignment.Right">
            <summary>
            An element aligned to the right of the layout slot for the parent element.
            </summary>     
        </member>
        <member name="F:Skill.UI.HorizontalAlignment.Stretch">
            <summary>
            An element stretched to fill the entire layout slot of the parent element.
            </summary>
        </member>
        <member name="T:Skill.UI.Group">
            <summary>
            A group of controls
            </summary>
        </member>
        <member name="T:Skill.UI.Canvas">
            <summary>    
            Defines an area within which you can explicitly position child elements by
            using coordinates that are relative to the Canvas area.    
            </summary>
        </member>
        <member name="M:Skill.UI.Canvas.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="M:Skill.UI.Group.#ctor">
            <summary>
            Create new instance of Group
            </summary>        
        </member>
        <member name="M:Skill.UI.Group.BeginRender">
            <summary> Begin render contents </summary>
        </member>
        <member name="M:Skill.UI.Group.EndRender">
            <summary> End render contents </summary>
        </member>
        <member name="P:Skill.UI.Group.Content">
            <summary>
            Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out,
            no background is rendered, and mouse clicks are passed
            </summary>
        </member>
        <member name="P:Skill.UI.Group.Style">
            <summary>
            The style to use. If null, the style from the current GUISkin is used.
            </summary>
        </member>
        <member name="T:Skill.Animation.MoveDirection">
            <summary>
            Defines 4 main direction
            </summary>
        </member>
        <member name="F:Skill.Animation.MoveDirection.Forward">
            <summary> Forward direction </summary>
        </member>
        <member name="F:Skill.Animation.MoveDirection.Backward">
            <summary> Backward direction </summary>
        </member>
        <member name="F:Skill.Animation.MoveDirection.Left">
            <summary> Left direction </summary>
        </member>
        <member name="F:Skill.Animation.MoveDirection.Right">
            <summary> Right direction  </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeBlend4Directional">
            <summary>
            This blend node allows the Anim Tree to automatically blend between four inputs which represent the owning actor moving forwards, backwards, strafing left and strafing right.
            The blend node compares the direction of velocity or acceleration to the direction of the owning actor. 
            Depending on the differences between the two, it will switch between the inputs.
            http://udn.epicgames.com/Three/AnimationNodes.html#AnimNodeBlendDirectional
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlend4Directional.#ctor">
            <summary>
            Create an instance of AnimNodeBlend4Directional
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlend4Directional.Forward">
            <summary> Forward child node </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlend4Directional.Backward">
            <summary> Backward child node </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlend4Directional.Left">
            <summary> Left child node </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlend4Directional.Right">
            <summary> Right child node </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlend4Directional.Angle">
            <summary>
            Angle of actor in local space
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlend4Directional.Direction">
            <summary>
            current direction of actor based of angle
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimationLayerManager">
            <summary>
            Contains AnimationLayers of an AnimationTree
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimationLayerManager.#ctor">
            <summary>
            Create an instance of AnimationLayerManager
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimationLayerManager.Create(UnityEngine.AnimationBlendMode)">
            <summary>
            Create new layer with specified AnimationBlendMode
            </summary>
            <param name="blendMode">AnimationBlendMode</param>
            <returns>New create and regitered AnimationLayer</returns>
        </member>
        <member name="P:Skill.Animation.AnimationLayerManager.Layers">
            <summary>
            List of AnimationLayer. (do not modify manually)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationLayerManager.EnableAnimNodeSequenceCount">
            <summary>
            Retrieves number of AnimNodeSequence that updated in current update(frame)
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeAimOffset">
            <summary>
            In a game, you often want a weapon held by a character to point where that player is aiming.
            Because an actor is defined by a collision cylinder that is only able to rotate on the yaw axis and not the pitch or roll axis,
            it's difficult to simply rotate the actor to make the player's aim.
            Even then, you may want the character's feet to remain locked in place.
            
            for more information : 
            http://udn.epicgames.com/Three/AnimationNodes.html#AnimNodeAimOffset
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.CenterCenterIndex">
            <summary> Index of CenterCenter child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.CenterUpIndex">
            <summary> Index of Centerup child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.CenterDownIndex">
            <summary> Index of CenterDown child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.LeftCenterIndex">
            <summary> Index of LeftCenter child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.LeftUpIndex">
            <summary> Index of LeftUp child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.LeftDownIndex">
            <summary> Index of LeftDown child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.RightCenterIndex">
            <summary> Index of RightCenter child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.RightUpIndex">
            <summary> Index of RightUp child</summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeAimOffset.RightDownIndex">
            <summary> Index of RightDown child</summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.OnProfileChanged">
            <summary>
            call ProfileChanged event and set new profile to children
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.#ctor">
            <summary>
            Create an instance of AnimNodeAimOffset node
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize and collect information from animationComponent
            </summary>
            <param name="animationComponent">UnityEngine.Animation</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.SetFormat(System.String)">
            <summary>
            Set format of all profiles
            </summary>
            <param name="format"></param>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.CalcBlendWeights(System.Single[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.SelectLayer(Skill.Animation.AnimationLayerManager,Skill.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.Destroy">
            <summary>
            Destroy hierarchy of Children
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.GetProfile(System.String)">
            <summary>
            Get profile by index
            </summary>
            <param name="profile">name of profile</param>
            <returns>if success AnimNodeAimOffsetProfile, otherwise null</returns>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.AddProfile(Skill.Animation.AnimNodeAimOffsetProfile)">
            <summary>
            Add new AnimNodeAimOffsetProfile
            </summary>
            <param name="profile">AnimNodeAimOffsetProfile to add</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.RemoveAllProfiles">
            <summary>
            Remove all profiles
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.Contains(Skill.Animation.AnimNodeAimOffsetProfile)">
            <summary>
            Determines whether specified profile is in profiles
            </summary>
            <param name="profile">profile to check</param>
            <returns>true if contains, otherwise false</returns>
        </member>
        <member name="M:Skill.Animation.AnimNodeAimOffset.RemoveProfile(Skill.Animation.AnimNodeAimOffsetProfile)">
            <summary>
            Remove specified profile
            </summary>
            <param name="profile">profile to remove</param>
            <returns>true for success, otherwise false</returns>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.AimWeight">
            <summary>
            Get or set weight of node (0.0f - 1.0f)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.UseTreeProfile">
            <summary>
            Whether use AnimationTree profiling method?
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.IsLoop">
            <summary>
            Whether aim animations are loop? (default is false).
            </summary>
            <remarks>
            If aim animations are not loop, then set as ClampForever.
            </remarks>
        </member>
        <member name="E:Skill.Animation.AnimNodeAimOffset.ProfileChanged">
            <summary>
            Occurs when profile changed
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.NormalNode">
            <summary>
            The AnimNode that use input blendmode specified by parent
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.Profile">
            <summary>
            Get of set profile
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.IsAimEnable">
            <summary>
            Whether anim layer is enable?
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.Aim">
            <summary> Normalized vector aim offset./ </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.AngleOffset">
            <summary> Aim offset to append to Aim before processing.</summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.AimX">
            <summary> Normalized horizontal aim offset. </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.AimY">
            <summary> Normalized veritcal aim offset. </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.AngleOffsetX">
            <summary> Horizontal aim offset to append to Aim before processing. </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.AngleOffsetY">
            <summary> Vertical aim offset to append to Aim before processing. </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAimOffset.ProfileCount">
            <summary>
            Retrieves number of profiles
            </summary>
        </member>
        <member name="T:Skill.AI.DecoratorHandler">
            <summary>
            Represents the method to handle execution of Decorator by user
            </summary>    
            <param name="parameters">Parameters for handler</param>
            <returns>true for success, false for failure</returns>
        </member>
        <member name="T:Skill.AI.DecoratorType">
            <summary>
            Defines type of  Decorator
            </summary>
        </member>
        <member name="F:Skill.AI.DecoratorType.Default">
            <summary>
            Access of child specified by user function
            </summary>
        </member>
        <member name="F:Skill.AI.DecoratorType.AccessLimit">
            <summary>
            Limit execution of child node on access key.
            </summary>
        </member>
        <member name="T:Skill.AI.Decorator">
            <summary>
            Typically have only one child and are used to enforce a certain return state 
            or to implement timers to restrict how often the child will run in a given amount of time
            or how often it can be executed without a pause.(none leaf node)
            </summary>
        </member>
        <member name="T:Skill.AI.Behavior">
            <summary>
            Defines base class for all behavior nodes in BehaviorTree
            </summary>
        </member>
        <member name="M:Skill.AI.Behavior.#ctor(System.String,Skill.AI.BehaviorType)">
            <summary>
            Create an instance of Behavior
            </summary>
            <param name="name">Name of Behavior</param>
            <param name="behaviorType">Type of behavior (specified by subclass)</param>
        </member>
        <member name="M:Skill.AI.Behavior.Trace(Skill.AI.BehaviorState)">
            <summary>
            handle execution of behavior and call appropriate events
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns>Result of execution</returns>
        </member>
        <member name="M:Skill.AI.Behavior.Behave(Skill.AI.BehaviorState)">
            <summary>
            Let subclass implement behaveior
            </summary>
            <param name="state">State of BehaviorTre</param>
            <returns>Result of behavior</returns>
        </member>
        <member name="M:Skill.AI.Behavior.ToString">
            <summary>
            Represent Behavior as string
            </summary>
            <returns>String</returns>
        </member>
        <member name="M:Skill.AI.Behavior.ResetBehavior(System.Boolean)">
            <summary>
            Reset behavior. For internal use. when a branch with higher priority executed, let nodes in previous branch reset (internal use)
            </summary>        
            <param name="resetChildren">Reset children too</param>
        </member>
        <member name="P:Skill.AI.Behavior.Name">
            <summary>
            Name of Behavior
            </summary>
        </member>
        <member name="P:Skill.AI.Behavior.Type">
            <summary>
            Type of Behavior
            </summary>
        </member>
        <member name="P:Skill.AI.Behavior.Result">
            <summary>
            Last ecexution result of behavior
            </summary>
        </member>
        <member name="P:Skill.AI.Behavior.Weight">
            <summary>
            Wheight or chance of behavior when is behavior is child of a RandomSelector
            </summary>
        </member>
        <member name="P:Skill.AI.Behavior.Tag">
            <summary>
            User object data
            </summary>
        </member>
        <member name="M:Skill.AI.Decorator.SetChild(Skill.AI.Behavior,Skill.AI.BehaviorParameterCollection)">
            <summary>
            Set child of decorator
            </summary>
            <param name="child">Child behavior</param>
            <param name="parameters">Optional parameters for child behavior at this position of tree</param>
        </member>
        <member name="M:Skill.AI.Decorator.#ctor(System.String,Skill.AI.DecoratorHandler)">
            <summary>
            Create an instance of Decorator
            </summary>
            <param name="name">Name of behavior</param>
            <param name="handler">user provided function to handle execution of Decorator</param>
        </member>
        <member name="M:Skill.AI.Decorator.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State od BehaviorTree</param>
            <returns></returns>
        </member>
        <member name="M:Skill.AI.Decorator.ResetBehavior(System.Boolean)">
            <summary>
            Reset behavior
            </summary>        
            <param name="resetChildren">Reset children too</param>
        </member>
        <member name="P:Skill.AI.Decorator.Child">
            <summary>
            Single child node
            </summary>
        </member>
        <member name="P:Skill.AI.Decorator.DecoratorType">
            <summary>
            DecoratorType
            </summary>
        </member>
        <member name="P:Skill.AI.Decorator.NeverFail">
            <summary>
            set to true if only BehaviorResult.Running is important for you (default is true)
            </summary>
        </member>
        <member name="T:Skill.Managers.CacheObject">
            <summary>
            Information about an GameObject by CacheBehavior component
            </summary>
        </member>
        <member name="F:Skill.Managers.CacheObject.Prefab">
            <summary> Cacheable GameObject</summary>
        </member>
        <member name="F:Skill.Managers.CacheObject.InitialCacheSize">
            <summary> Number of instances to create at initialize time</summary>
        </member>
        <member name="F:Skill.Managers.CacheObject.MaxSize">
            <summary> If this object is Growable, grow until what size? </summary>
        </member>
        <member name="F:Skill.Managers.CacheObject.NamePatternFormat">
            <summary> C# string format use for names of CacheBehavior objects </summary>
        </member>
        <member name="F:Skill.Managers.CacheObject.Growable">
            <summary> Is Growable?</summary>
        </member>
        <member name="F:Skill.Managers.CacheObject.CleanInterval">
            <summary> After this time try to destroy some inactive objects to reach InitialCacheSize. (0 means never) </summary>
        </member>
        <member name="M:Skill.Managers.CacheObject.Initialize(Skill.Managers.CacheGroup)">
            <summary>
            Initialize and instantiate objects
            </summary>
            <param name="group"></param>
        </member>
        <member name="M:Skill.Managers.CacheObject.Next">
            <summary>
            Get next available and deactive object to reuse
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Managers.CacheObject.Free(UnityEngine.GameObject)">
            <summary>
            Add unused GameObject to free list
            </summary>
            <param name="objToFree"> unused GameObject </param>
        </member>
        <member name="M:Skill.Managers.CacheObject.Destroy">
            <summary>
            Destroy all instances
            </summary>
        </member>
        <member name="M:Skill.Managers.CacheObject.Clean">
            <summary>
            Clean
            </summary>
        </member>
        <member name="P:Skill.Managers.CacheObject.Group">
            <summary> Group </summary>
        </member>
        <member name="P:Skill.Managers.CacheObject.CacheId">
            <summary> Unique id (same as CacheBehavior.CacheId ) </summary>
        </member>
        <member name="T:Skill.UI.TextField">
            <summary>
            Make a single-line text field where the user can edit a string.
            </summary>
        </member>
        <member name="M:Skill.UI.TextField.OnTextChanged">
            <summary>
            Occurs when text of TextField changed
            </summary>
        </member>
        <member name="M:Skill.UI.TextField.#ctor">
            <summary>
            Create an instance of TextField
            </summary>
        </member>
        <member name="M:Skill.UI.TextField.Render">
            <summary>
            Render TextField
            </summary>
        </member>
        <member name="P:Skill.UI.TextField.Text">
            <summary>
            Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            </summary>
        </member>
        <member name="E:Skill.UI.TextField.TextChanged">
            <summary>
            Occurs when text of TextField changed
            </summary>
        </member>
        <member name="P:Skill.UI.TextField.MaxLength">
            <summary>
            The maximum length of the string. If left out, the user can type for ever and ever.
            </summary>
        </member>
        <member name="P:Skill.UI.TextField.Converter">
            <summary>
            Text conveter for other languages (like persian)
            </summary>
        </member>
        <member name="T:Skill.Text.PersianTextFieldConverter">
            <summary>
            Convert a text contains of none persian characters to equivalent persian characters.
            </summary>
            <remarks>
            this version of converter use more calculation to convert text and should use for left to right TextField.
            so use this class when your text is dynamic and 
            </remarks>
        </member>
        <member name="T:Skill.Text.ITextConverter">
            <summary>
            Convert text to other format(in other language)
            </summary>
        </member>
        <member name="M:Skill.Text.ITextConverter.Convert(System.String)">
            <summary>
            Convert specified text
            </summary>
            <param name="source">Source text to convert</param>
            <returns>Converted text</returns>
        </member>
        <member name="M:Skill.Text.PersianTextFieldConverter.#ctor(Skill.Text.IPersianCharacterMap,System.Int32)">
            <summary>
            Create a PersianTextConverter
            </summary>
            <param name="characterMap">Character mapping information for persian language</param>
            <param name="maxLength">Maximum length of text ( for better performance)</param>
        </member>
        <member name="M:Skill.Text.PersianTextFieldConverter.Convert(System.String)">
            <summary>
            Convert specified text to equivalent persian text
            </summary>
            <param name="text">Text to convert</param>
            <returns>Converted text</returns>
        </member>
        <member name="P:Skill.Text.PersianTextFieldConverter.CharacterMap">
            <summary>
            IPersianCharacterMap provided for this converter
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextFieldConverter.MaxLength">
            <summary>
            Maximum length of text ( for better performance)
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextFieldConverter.LastConvertedText">
            <summary>
            Retrieves last converted text by this converter
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextFieldConverter.ConvertLigature">
            <summary>
            Whether convert لا and الله to one equivalent character. (default false)
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextFieldConverter.TextToSave">
            <summary>
            This is reversed text to save.
            </summary>
            <remarks>
            When we set text of TextField for first time the converter does not know that this text reversed before
            so it will reverse it and the result in TextFiled gets wrong.
            </remarks>
        </member>
        <member name="T:Skill.Text.IPersianCharacterMap">
            <summary>
            Defines character mapping information for persian language
            </summary>
        </member>
        <member name="P:Skill.Text.IPersianCharacterMap.Map">
            <summary>
            A dictionary that maps each word to equivalent persian character
            </summary>
        </member>
        <member name="T:Skill.UI.PasswordField">
            <summary>
            Make a text field where the user can enter a password.
            </summary>
        </member>
        <member name="M:Skill.UI.PasswordField.OnPasswordChanged">
            <summary>
            when password changed
            </summary>
        </member>
        <member name="M:Skill.UI.PasswordField.#ctor">
            <summary>
            Create an instance of PasswordField
            </summary>
        </member>
        <member name="M:Skill.UI.PasswordField.Render">
            <summary>
            Render PasswordField
            </summary>
        </member>
        <member name="P:Skill.UI.PasswordField.Password">
            <summary>
            Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            </summary>
        </member>
        <member name="E:Skill.UI.PasswordField.PasswordChanged">
            <summary>
            Occurs when password changed
            </summary>
        </member>
        <member name="P:Skill.UI.PasswordField.MaxLength">
            <summary>
            The maximum length of the string. If left out, the user can type for ever and ever.
            </summary>
        </member>
        <member name="P:Skill.UI.PasswordField.MaskChar">
            <summary>
            Character to mask the password with.(default '•')
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeOverride">
            <summary>
            place children nodes in different layers.
            </summary>
            <remarks>
            for example :
            almost in reload AnimationClips only hand bones involved and other bones do not have keys.
            you can use this node to override hand animations so the lower body can play another animation
            be sure that lower body bones do not have any keys in AnimationClip or set MixingTransforms for bones
            Another usage of this nodeis when you want to play an IdleBreak animation sometimes
            </remarks>
        </member>
        <member name="T:Skill.Animation.AnimNodeMultilayer">
            <summary>
            base class for AnimNodes that use multiple layers for children
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeMultilayer.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeMultilayer
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeMultilayer.SelectLayer(Skill.Animation.AnimationLayerManager,Skill.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeOverride.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeOverride
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeOverride.OnBecameRelevant(Skill.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeOverride.OnCeaseRelevant(Skill.Animation.AnimationTreeState)">
            <summary>
            call CeaseRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeOverride.Update(Skill.Animation.AnimationTreeState)">
            <summary>
            Update
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeOverride.CalcBlendWeights(System.Single[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeOverride.OverrideOneShot">
            <summary>
            Used when OverridePeriod is zero
            For example you can play reload one shot
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeOverride.OverrideOneShot(System.Int32)">
            <summary>
            Used when OverridePeriod is zero
            For example you can play reload one shot
            </summary>
            <param name="overrideIndex"> overriding node by index (index is between '1' - 'ChildCount -1' ) </param>
        </member>
        <member name="P:Skill.Animation.AnimNodeOverride.NormalNode">
            <summary>
            Normal node
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeOverride.OverrideNode">
            <summary>
            Override Node (higher layer)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeOverride.OverrideIndex">
            <summary>
            Get or set active overriding node by index (index is between '1' - 'ChildCount -1' )
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeOverride.IsOverriding">
            <summary>
            Whether overriding brach enable?
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeOverride.OverridePeriod">
            <summary>
            if true, node automatically override one shot at period time
            </summary>
            <remarks>
            can be used on IdleBreak, set idle to NormalNode and idlebreak(could be an AnimNodeRandom) to OverrideNode.
            remember to disable IsOverriding when actor is not idle
            </remarks>
        </member>
        <member name="P:Skill.Animation.AnimNodeOverride.Length">
            <summary>
            Lenght of active branch
            </summary>
        </member>
        <member name="T:Skill.AI.LoopSelector">
            <summary>
            Loops are like sequences but they loop around when reaching their last child during their traversal.
            if reach last child and it returns Success. this node returns Running and continue from first child at next update.
            we do this to avoid fall into infinit loop
            </summary>
        </member>
        <member name="T:Skill.AI.Composite">
            <summary>
            Defines base class for composit behaviors
            </summary>
        </member>
        <member name="M:Skill.AI.Composite.#ctor(System.String)">
            <summary>
            Create an instance of Composite
            </summary>
            <param name="name">Name of behavior node</param>
        </member>
        <member name="M:Skill.AI.Composite.Add(Skill.AI.Behavior,Skill.AI.BehaviorParameterCollection)">
            <summary>
            Add child. Remember to add children in correct priority
            </summary>
            <param name="child">Child behavior node</param>
            <param name="parameters">optional parameters for behavior</param>
        </member>
        <member name="M:Skill.AI.Composite.Add(Skill.AI.Behavior)">
            <summary>
            Add child. Remember to add children in correct priority
            </summary>
            <param name="child">Child behavior node</param>        
        </member>
        <member name="M:Skill.AI.Composite.RemoveAll">
            <summary>
            remove all children
            </summary>
        </member>
        <member name="M:Skill.AI.Composite.Remove(Skill.AI.Behavior)">
            <summary>
            Remove specified child
            </summary>
            <param name="child">child to remove</param>
            <returns></returns>
        </member>
        <member name="M:Skill.AI.Composite.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through children
            </summary>
            <returns>enumerator that iterates through children</returns>
        </member>
        <member name="M:Skill.AI.Composite.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through children
            </summary>
            <returns>enumerator that iterates through children</returns>
        </member>
        <member name="M:Skill.AI.Composite.ResetBehavior(System.Boolean)">
            <summary>
            Reset behavior
            </summary>        
            <param name="resetChildren">Reset children too</param>
        </member>
        <member name="M:Skill.AI.Composite.IsInSequenceChild(Skill.AI.Behavior,Skill.AI.Behavior)">
            <summary>
            Checks whether behavior2 is one of next siblings of behavior1
            </summary>
            <param name="behavior1">firsy behavior</param>
            <param name="behavior2">next behavior</param>
            <returns>True if behavior2 is one of next siblings of behavior1, otherwise false</returns>
        </member>
        <member name="P:Skill.AI.Composite.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="P:Skill.AI.Composite.RunningChildIndex">
            <summary>
            Index of child that already running and needs to update next frame
            </summary>
        </member>
        <member name="P:Skill.AI.Composite.Item(System.Int32)">
            <summary>
            Access children by index
            </summary>
            <param name="index">Index of children</param>
            <returns>Child at specified index</returns>
        </member>
        <member name="P:Skill.AI.Composite.ChildCount">
            <summary>
            Retrieves count of children
            </summary>
        </member>
        <member name="M:Skill.AI.LoopSelector.#ctor(System.String)">
            <summary>
            Create an instance of LoopSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.AI.LoopSelector.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns>esult</returns>
        </member>
        <member name="P:Skill.AI.LoopSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="P:Skill.AI.LoopSelector.LoopCount">
            <summary> number of loop (-1 for infinit)</summary>
        </member>
        <member name="T:Skill.SmoothType">
            <summary>
            Types of smoothing
            </summary>
        </member>
        <member name="F:Skill.SmoothType.Damp">
            <summary> Just using SmoothTime value of SmoothingParams</summary>
        </member>
        <member name="F:Skill.SmoothType.DampSpeed">
            <summary> using SmoothTime and MaxSpeed value of SmoothingParams</summary>
        </member>
        <member name="F:Skill.SmoothType.DampSpeedAndTime">
            <summary> using SmoothTime, MaxSpeed and DeltaTimeFactor value of SmoothingParams</summary>
        </member>
        <member name="T:Skill.SmoothingParameters">
            <summary>
            Parameters of Smoothing algorithm
            </summary>
        </member>
        <member name="F:Skill.SmoothingParameters.SmoothType">
            <summary> Type of Smoothing </summary>
        </member>
        <member name="F:Skill.SmoothingParameters.SmoothTime">
            <summary> Approximately the time it will take to reach the target. A smaller value will reach the target faster.</summary>
        </member>
        <member name="F:Skill.SmoothingParameters.MaxSpeed">
            <summary> Optionally allows you to clamp the maximum speed. </summary>
        </member>
        <member name="F:Skill.SmoothingParameters.DeltaTimeFactor">
            <summary> The factor of Time.deltaTime( The time since the last call to this function ). </summary>
        </member>
        <member name="T:Skill.Smoothing">
            <summary>
            Simplify using Mathf.SmoothDamp
            </summary>
        </member>
        <member name="F:Skill.Smoothing.Target">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="M:Skill.Smoothing.Update(Skill.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="P:Skill.Smoothing.Current">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="T:Skill.SmoothingAngle">
            <summary>
            Simplify using Mathf.SmoothDampAngle
            </summary>
        </member>
        <member name="F:Skill.SmoothingAngle.TargetAngle">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="M:Skill.SmoothingAngle.Update(Skill.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="P:Skill.SmoothingAngle.CurrentAngle">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="T:Skill.Smoothing2">
            <summary>
            Simplify using Mathf.SmoothDamp for two value
            </summary>
        </member>
        <member name="M:Skill.Smoothing2.Update(Skill.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="P:Skill.Smoothing2.Current">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="P:Skill.Smoothing2.Target">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="T:Skill.Smoothing3">
            <summary>
            Simplify using Mathf.SmoothDamp for two value
            </summary>
        </member>
        <member name="M:Skill.Smoothing3.Update(Skill.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="P:Skill.Smoothing3.Current">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="P:Skill.Smoothing3.Target">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="T:Skill.AI.CompositeType">
            <summary>
            Defines type of Composite nodes that implemented in this library
            </summary>
        </member>
        <member name="F:Skill.AI.CompositeType.Sequence">
            <summary>
            run one child to finish after the other. If one or multiple fail the whole sequence fails, too.
            Without a reset or without finishing the last child node a sequence stores the last running child to immediately return to it on the next update.
            </summary>
        </member>
        <member name="F:Skill.AI.CompositeType.Concurrent">
            <summary>
            visit all of their children during each traversal.
            A pre-specified number of children needs to fail to make the concurrent node fail, too.
            Instead of running its child nodes truly in parallel to each other there might be a specific traversal order which can be exploited when adding conditions
            to a concurrent node because an early failing condition prevents its following concurrent siblings from running.
            </summary>
        </member>
        <member name="F:Skill.AI.CompositeType.Random">
            <summary>
            select a random child by chance for execution.
            </summary>
        </member>
        <member name="F:Skill.AI.CompositeType.Priority">
            <summary>
            On each traversal priority selectors check which child to run in priority order until the first one succeeds or returns that it is running.
            One option is to call the last still running node again during the next behavior tree update. The other option is to always restart traversal
            from the highest priority child and implicitly cancel the last running child behavior if it isn’t chosen immediately again.
            </summary>
        </member>
        <member name="F:Skill.AI.CompositeType.Loop">
            <summary>
            Loops are like sequences but they loop around when reaching their last child during their traversal instead of returning to their parent node like sequence node do.
            </summary>
        </member>
        <member name="T:Skill.UI.ColumnDefinition">
            <summary>
            Defines column-specific properties that apply to Grid elements.
            </summary>
        </member>
        <member name="M:Skill.UI.ColumnDefinition.#ctor">
            <summary>
            Initializes a new instance of the ColumnDefinition class.
            </summary>
        </member>
        <member name="P:Skill.UI.ColumnDefinition.Width">
            <summary>
             Gets the calculated width of a ColumnDefinition element,
             or sets the GridLength value of a column that is defined by the ColumnDefinition.
            </summary>
        </member>
        <member name="P:Skill.UI.ColumnDefinition.MaxWidth">
            <summary>
            Gets or sets a value that represents the maximum width of a ColumnDefinition.
            </summary>
        </member>
        <member name="P:Skill.UI.ColumnDefinition.MinWidth">
            <summary>
            Gets or sets a value that represents the minimum width of a ColumnDefinition.
            </summary>
        </member>
        <member name="T:Skill.UI.ColumnDefinitionCollection">
            <summary>
            Provides access to an ordered, strongly typed collection of ColumnDefinition objects.
            </summary>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.#ctor">
            <summary>
            Create a instance of ColumnDefinitionCollection class
            </summary>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.Add(Skill.UI.ColumnDefinition)">
            <summary>
            Adds a ColumnDefinition element to a ColumnDefinitionCollection.
            </summary>
            <param name="value">Identifies the ColumnDefinition to add to the collection.</param>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.Clear">
            <summary>
            Clears the content of the ColumnDefinitionCollection.
            </summary>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.Contains(Skill.UI.ColumnDefinition)">
            <summary>
            Determines whether a given ColumnDefinition exists within a ColumnDefinitionCollection.
            </summary>
            <param name="value"> Identifies the ColumnDefinition that is being tested. </param>
            <returns>true if the ColumnDefinition exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.CopyTo(Skill.UI.ColumnDefinition[],System.Int32)">
            <summary>
             Copies an array of ColumnDefinition objects to a given index position within a ColumnDefinitionCollection.
            </summary>
            <param name="array"> An array of ColumnDefinition objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the ColumnDefinition objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.Remove(Skill.UI.ColumnDefinition)">
            <summary>
            Removes a ColumnDefinition from a ColumnDefinitionCollection.
            </summary>
            <param name="value"> The ColumnDefinition to remove from the collection. </param>
            <returns> true if the ColumnDefinition was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltColumnDefinition;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.UI.ColumnDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="P:Skill.UI.ColumnDefinitionCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a ColumnDefinitionCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="E:Skill.UI.ColumnDefinitionCollection.Change">
            <summary>
            Occurs when any changes happens to collection (Add, Remove, Clear)
            </summary>
        </member>
        <member name="P:Skill.UI.ColumnDefinitionCollection.Count">
            <summary>
            Gets the total number of items within this instance of ColumnDefinitionCollection.
            </summary>
        </member>
        <member name="P:Skill.UI.ColumnDefinitionCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a ColumnDefinitionCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimationTree">
            <summary>
            Base class for AnimationTrees
            </summary>
            <remarks>
            The AnimationTree use unity Animation Layers system ( see .... )
            All AnimNodes in AnimationTre seprated to two category SingleLayer and MultiLayer
            SingleLayers AnimNodes use single layer to blend between their children, whitch means use same layer index for all children
            MultiLayer AnimNodes use a layer per child and blend them togather (like BlendByIdle)
            to know about which AnimNode inherites from SingleLayer or MultiLayer see hierarchy inheritance of classes
            the idea of designing this AnimationTree system comes from Unreal Engine AnimaionTree ( see : http://udn.epicgames.com/Three/AnimationNodes.html )
            </remarks>
        </member>
        <member name="M:Skill.Animation.AnimationTree.CreateTree">
            <summary>
            Override by subclass to create hierarchy of AnimNodes and return root node
            </summary>
            <returns>Root node of tree</returns>
        </member>
        <member name="M:Skill.Animation.AnimationTree.#ctor">
            <summary>
            Create an instance of AnimationTree
            </summary>        
        </member>
        <member name="M:Skill.Animation.AnimationTree.AddProfile(System.String,System.String)">
            <summary>
            Add new profile
            </summary>
            <param name="name">Name of profile</param>
            <param name="format">Format of profile in C#</param>        
        </member>
        <member name="M:Skill.Animation.AnimationTree.RemoveProfile(System.String)">
            <summary>
            Remove profile by name
            </summary>
            <param name="name">Name of profile</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Animation.AnimationTree.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize UnityEngine.Animation. call this at 'Awake', or 'Start' method of MonoBehavior based class
            </summary>
            <param name="animationComponent">UnityEngine.Animation to initialize</param>        
        </member>
        <member name="M:Skill.Animation.AnimationTree.SyncLayers(UnityEngine.Animation)">
            <summary>
            Sync all layers used in this AnimationTree. (maybe not useful because we do'nt use 'CrossFade' method)
            </summary>
            <param name="animationComponent">UnityEngine.Animation to sync layers</param>
        </member>
        <member name="M:Skill.Animation.AnimationTree.Update(Skill.Controllers.Controller)">
            <summary>
            Update AnimationTree in new state each frame
            </summary>
            <param name="controller">optional controller to send throw AnimNodes</param>
        </member>
        <member name="M:Skill.Animation.AnimationTree.Apply(UnityEngine.Animation)">
            <summary>
            Apply AnimationTree
            </summary>
            <param name="animationComponent">UnityEngine.Animation to update</param>                       
            <remarks>
            you can apply this AnimationTree to more than one UnityEngine.Animation each frame (instancing)
            Make sure default AnimationClip of Animation setted to 'none' in editor
            </remarks>
        </member>
        <member name="M:Skill.Animation.AnimationTree.Destroy">
            <summary>
            Destroy hierarchy
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationTree.LayerCount">
            <summary>
            Maximum layer used by this AnimationTree
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationTree.Root">
            <summary>
            The root AnimNode
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationTree.UserData">
            <summary>
            User data
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationTree.LayerManager">
            <summary>
            LayerManager
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationTree.Profile">
            <summary>
            Get or set profile by name
            </summary>
            <remarks>
            Profiles can be used in situations like : you want to swich weapon type (Rifle, Pistol, ...)
            all of this weapons have same AnimationClips (Reload, Fire, RunForward, WalkForward, ...).
            in such situations it's possible to name AnimationClips in standard format like this :
            
            Rifle_Reload,  Rifle_Fire,  Rifle_RunForward,  Rifle_WalkForward,   ...
            Pistol_Reload, Pistol_Fire, Pistol_RunForward, Pistol_WalkForward, ...
            
            by this naming method the formats of profiles can be
            
            Rifle_{0}
            Pistol_{0}
                    
            then set AnimationName property of AnimNodeSequences to
            
            Reload,  Fire,  RunForward,  WalkForward,   ...
            
            by this method at any time you can switch between weapons.
            </remarks>
        </member>
        <member name="P:Skill.Animation.AnimationTree.RootMotion">
            <summary> Retrieves RootMotion at current frame </summary>
        </member>
        <member name="T:Skill.UI.Thickness">
            <summary>
            Describes the thickness of a frame around a rectangle. 
            Four float values describe the Thickness.Left, Thickness.Top, Thickness.Right, and Thickness.Bottom sides of the rectangle, respectively.
            </summary>
        </member>
        <member name="M:Skill.UI.Thickness.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the Thickness structure that has the specified uniform length on each side.
            </summary>
            <param name="uniformLength">The uniform length applied to all four sides of the bounding rectangle.</param>
        </member>
        <member name="M:Skill.UI.Thickness.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the Thickness structure that has specific lengths (supplied as a System.Double) applied to each side of the rectangle.
            </summary>
            <param name="left"> The thickness for the left side of the rectangle.</param>
            <param name="top">The thickness for the upper side of the rectangle.</param>
            <param name="right">The thickness for the right side of the rectangle</param>
            <param name="bottom">The thickness for the lower side of the rectangle.</param>
        </member>
        <member name="M:Skill.UI.Thickness.Equals(System.Object)">
            <summary>
            Compares this Thickness structure to another System.Object for equality.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>true if the two objects are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.UI.Thickness.Equals(Skill.UI.Thickness)">
            <summary>
             Compares this Thickness structure to another Thickness structure for equality.
            </summary>
            <param name="thickness"> An instance of Thickness to compare for equality.</param>
            <returns>true if the two instances of Thickness are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.UI.Thickness.GetHashCode">
            <summary>
            Returns the hash code of the structure.
            </summary>
            <returns> A hash code for this instance of Thickness. </returns>
        </member>
        <member name="M:Skill.UI.Thickness.ToString">
            <summary>
            Returns the string representation of the Thickness structure.
            </summary>
            <returns>A System.String that represents the Thickness value.</returns>
        </member>
        <member name="M:Skill.UI.Thickness.op_Equality(Skill.UI.Thickness,Skill.UI.Thickness)">
            <summary>
            Compares the value of two Thickness structures for equality.
            </summary>
            <param name="t1">The first structure to compare.</param>
            <param name="t2">The other structure to compare.</param>
            <returns>true if the two instances of Thickness are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.UI.Thickness.op_Inequality(Skill.UI.Thickness,Skill.UI.Thickness)">
            <summary>
            Compares two Thickness structures for inequality.
            </summary>
            <param name="t1">The first structure to compare.</param>
            <param name="t2">The other structure to compare.</param>
            <returns>true if the two instances of Thickness are not equal; otherwise, false.</returns>
        </member>
        <member name="P:Skill.UI.Thickness.Left">
            <summary>
            Gets or sets the width, in pixels, of the left side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.UI.Thickness.Top">
            <summary>
            Gets or sets the width, in pixels, of the upper side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.UI.Thickness.Right">
            <summary>
            Gets or sets the width, in pixels, of the right side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.UI.Thickness.Bottom">
            <summary>
             Gets or sets the width, in pixels, of the lower side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.UI.Thickness.Horizontal">
            <summary>
            Left + Right
            </summary>
        </member>
        <member name="P:Skill.UI.Thickness.Vertical">
            <summary>
            Top + Bottom
            </summary>
        </member>
        <member name="P:Skill.UI.Thickness.Empty">
            <summary>
            zero Thickness
            </summary>
        </member>
        <member name="T:Skill.UI.Label">
            <summary>
            Make a text or texture label on screen.
            </summary>
        </member>
        <member name="M:Skill.UI.Label.#ctor">
            <summary>
            Create an instance of Lable
            </summary>
        </member>
        <member name="M:Skill.UI.Label.Render">
            <summary>
            Render Label
            </summary>
        </member>
        <member name="P:Skill.UI.Label.Content">
            <summary>
            Text, image and tooltip for this label.
            </summary>
        </member>
        <member name="P:Skill.UI.Label.Text">
            <summary>
            Text to display on the label.
            </summary>
        </member>
        <member name="T:Skill.UI.Image">
            <summary>
            Draw a texture within a rectangle.
            </summary>
        </member>
        <member name="M:Skill.UI.Image.#ctor">
            <summary>
            Create an instance of Image
            </summary>
        </member>
        <member name="M:Skill.UI.Image.Render">
            <summary>
            Render Image
            </summary>
        </member>
        <member name="P:Skill.UI.Image.Texture">
            <summary>
            Texture to display.
            </summary>
        </member>
        <member name="P:Skill.UI.Image.Scale">
            <summary>
            How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            </summary>
        </member>
        <member name="P:Skill.UI.Image.AlphaBlend">
            <summary>
            Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
            </summary>
        </member>
        <member name="P:Skill.UI.Image.ImageAspect">
            <summary>
            Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
            Pass in w/h for the desired aspect ratio.
            This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            </summary>
        </member>
        <member name="P:Skill.UI.Image.TextureCoordinate">
            <summary>
            Draw a texture within a rectangle with the given texture coordinates.
            </summary>
        </member>
        <member name="P:Skill.UI.Image.UseTextureCoordinate">
            <summary>
            Whether use coordinate. Use this function for clipping or tiling the image within the given rectangle. 
            </summary>
        </member>
        <member name="T:Skill.UI.GridUnitType">
            <summary>
            Describes the kind of value that a GridLength object is holding.
            </summary>
        </member>
        <member name="F:Skill.UI.GridUnitType.Auto">
            <summary>
            The size is determined by the size properties of the content object.
            </summary>
        </member>
        <member name="F:Skill.UI.GridUnitType.Pixel">
            <summary>
            The value is expressed as a pixel.
            </summary>
        </member>
        <member name="F:Skill.UI.GridUnitType.Star">
            <summary>
            The value is expressed as a weighted proportion of available space.
            </summary>
        </member>
        <member name="T:Skill.Animation.WeightChangeMode">
            <summary>
            Defines weight state of AnimNode
            </summary>
        </member>
        <member name="F:Skill.Animation.WeightChangeMode.NoChange">
            <summary>
            No changes occurs between this and previous update
            </summary>
        </member>
        <member name="F:Skill.Animation.WeightChangeMode.Increased">
            <summary>
            The value of Weight increased depend on previous update
            </summary>
        </member>
        <member name="F:Skill.Animation.WeightChangeMode.Decreased">
            <summary>
            The value of Weight decreased depend on previous update
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeEventHandler">
            <summary>
            Represents the method that will handle events of AnimNpde
            </summary>
            <param name="sender">The actual AnimNode that this even belongs to</param>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="T:Skill.Managers.CacheLifeTime">
            <summary>
            After specific time CacheObject automatically cached
            </summary>
        </member>
        <member name="F:Skill.Managers.CacheLifeTime.LifeTime">
            <summary>
            Life Time
            </summary>
        </member>
        <member name="F:Skill.Managers.CacheLifeTime.EnableOnAwake">
            <summary>
            Whether life time timer begins on awake
            </summary>
        </member>
        <member name="M:Skill.Managers.CacheLifeTime.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Managers.CacheLifeTime.OnEnable">
            <summary>
            On Enable
            </summary>
        </member>
        <member name="M:Skill.Managers.CacheLifeTime.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="T:Skill.Modules.DelayRender">
            <summary>
            Object vill be visible at specific time after instantiate
            </summary>
        </member>
        <member name="F:Skill.Modules.DelayRender.Delay">
            <summary> Delay time </summary>
        </member>
        <member name="M:Skill.Modules.DelayRender.OnEnable">
            <summary>
            OnEnable
            </summary>
        </member>
        <member name="M:Skill.Modules.DelayRender.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="T:Skill.Animation.AimHelper">
            <summary>
            Helper class to calculate anim for AnimNodeAimOffset
            </summary>
        </member>
        <member name="M:Skill.Animation.AimHelper.Update">
            <summary>
            Update AimHelper to calculate new aim vector
            </summary>
        </member>
        <member name="P:Skill.Animation.AimHelper.Aim">
            <summary>
            Calculated Aim vector
            </summary>
        </member>
        <member name="P:Skill.Animation.AimHelper.PitchMin">
            <summary> Gets or sets minimum value of pitch </summary>
        </member>
        <member name="P:Skill.Animation.AimHelper.PitchMax">
            <summary> Gets or sets maximum value of pitch </summary>
        </member>
        <member name="P:Skill.Animation.AimHelper.YawMin">
            <summary> Gets or sets minimum value of yaw </summary>
        </member>
        <member name="P:Skill.Animation.AimHelper.YawMax">
            <summary> Gets or sets maximum value of pitch </summary>
        </member>
        <member name="P:Skill.Animation.AimHelper.Direction">
            <summary> Local direction of aim relative to forward direction of actor </summary>
        </member>
        <member name="P:Skill.Animation.AimHelper.AimSpeed">
            <summary> Speed of aim </summary>
        </member>
        <member name="T:Skill.AI.BehaviorResult">
            <summary>
            Defines result of Behavior execution
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorResult.Failure">
            <summary>
            Failure
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorResult.Success">
            <summary>
            Success
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorResult.Running">
            <summary>
            Running. needs to run next update
            </summary>
        </member>
        <member name="T:Skill.AI.AccessKey">
            <summary>
            Defines base class for keys that used by AccessLimitDecorator
            </summary>
            <remarks>
            Contains a string key. Each BehaviorTree has it's own set of keys that shared among all AccessLimitDecorators
            Whenever a AccessLimitDecorator try to execute first must get access to key, otherwise fails.
            </remarks>
        </member>
        <member name="M:Skill.AI.AccessKey.#ctor(System.String)">
            <summary>
            Creates an insance of AccessKey
            </summary>
            <param name="accessKey">The Unique access key in BehaviorTree.</param>
        </member>
        <member name="M:Skill.AI.AccessKey.Lock">
            <summary>
            Implemented by subclass to defines how to lock key and if success returns true, otherwise false.
            </summary>
            <returns>True for success, false for fail</returns>
        </member>
        <member name="M:Skill.AI.AccessKey.Unlock">
            <summary>
            Implemented by subclass. this method called by AccessLimitDecorators after finish his work and free key to use by another AccessLimitDecorator.
            </summary>
        </member>
        <member name="P:Skill.AI.AccessKey.Key">
            <summary> The unique Accesskey in BehaviorTree.</summary>
        </member>
        <member name="T:Skill.AI.CounterLimitAccessKey">
            <summary>
            Only constant number of AccessLimitDecorators can access this key at the same time.
            </summary>
        </member>
        <member name="M:Skill.AI.CounterLimitAccessKey.#ctor(System.String,System.Int32)">
            <summary>
            Create an instance of CounterLimitAccessKey
            </summary>
            <param name="accessKey">The Unique access key in BehaviorTree.</param>
            <param name="maxAccessCount">Maximum number of AccessLimitDecorators to access this key</param>
        </member>
        <member name="M:Skill.AI.CounterLimitAccessKey.Lock">
            <summary>
            Defines how to lock key and if success returns true, otherwise false.
            </summary>
            <returns>True for success, false for fail</returns>
        </member>
        <member name="M:Skill.AI.CounterLimitAccessKey.Unlock">
            <summary>
            This method called by AccessLimitDecorators after finish his work and free key to use by another AccessLimitDecorator.
            </summary>
        </member>
        <member name="P:Skill.AI.CounterLimitAccessKey.MaxAccessCount">
            <summary>
            Defines maximum number of AccessLimitDecorators to access this key
            </summary>
        </member>
        <member name="T:Skill.AI.TimeLimitAccessKey">
            <summary>
            Only first request accepted after TimeInterval and lock untile next TimeInterval
            </summary>
        </member>
        <member name="M:Skill.AI.TimeLimitAccessKey.#ctor(System.String,System.Single)">
            <summary>
            Create an instance of TimeLimitAccessKey
            </summary>
            <param name="accessKey">The Unique access key in BehaviorTree.</param>
            <param name="timeInterval">time interval between access to key</param>
        </member>
        <member name="M:Skill.AI.TimeLimitAccessKey.Lock">
            <summary>
            Defines how to lock key and if success returns true, otherwise false.
            </summary>
            <returns>True for success, false for fail</returns>
        </member>
        <member name="M:Skill.AI.TimeLimitAccessKey.Unlock">
            <summary>
            This method called by AccessLimitDecorators after finish his work and free key to use by another AccessLimitDecorator.
            </summary>
        </member>
        <member name="P:Skill.AI.TimeLimitAccessKey.TimeInterval">
            <summary>
            Defines time interval between access to key
            </summary>
        </member>
        <member name="T:Skill.AI.AccessLimitDecorator">
            <summary>
            Limit execution of child node on access key.
            </summary>
            <remarks>
            Each BehaviorTree has set of AccessKey that shared among all AccessLimitDecorators in that BehaviorTree.
            Whenever a AccessLimitDecorator try to execute, first check AccessKey and continue if get access, otherwise returns BehaviorResul.Failure
            </remarks>
        </member>
        <member name="M:Skill.AI.AccessLimitDecorator.#ctor(System.String,Skill.AI.AccessKey)">
            <summary>
            Create an instance of AccessLimitDecorator
            </summary>
            <param name="name">Name of behavior node</param>
            <param name="accessKey">Shared AccessKey</param>
        </member>
        <member name="M:Skill.AI.AccessLimitDecorator.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="M:Skill.AI.AccessLimitDecorator.ResetBehavior(System.Boolean)">
            <summary>
            Reset behavior. when a branch with more periority be valid let this nod to unlock key
            </summary>       
            <param name="resetChildren">Reset children too</param>
        </member>
        <member name="P:Skill.AI.AccessLimitDecorator.AccessKey">
            <summary>
            Shared AccessKey
            </summary>
        </member>
        <member name="P:Skill.AI.AccessLimitDecorator.DecoratorType">
            <summary>
            Type of Decorator
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimPosture">
            <summary>
            Defines possible posture of actor
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimPosture.Standing">
            <summary>
            Standing
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimPosture.Crouched">
            <summary>
            Crouched
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimPosture.Prone">
            <summary>
            Prone
            </summary>
        </member>
        <member name="T:Skill.AI.SequenceSelector">
            <summary>
            run one child to finish after the other. If one or multiple fail the whole sequence fails, too.
            Without a reset or without finishing the last child node a sequence stores the last running child to immediately return to it on the next update.
            </summary>
        </member>
        <member name="M:Skill.AI.SequenceSelector.#ctor(System.String)">
            <summary>
            Create an instance of SequenceSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.AI.SequenceSelector.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State od BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="P:Skill.AI.SequenceSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="T:Skill.Animation.Vector3Keyframes">
            <summary>
            Defines keyframes for a 3 float component
            </summary>
        </member>
        <member name="M:Skill.Animation.Vector3Keyframes.#ctor(UnityEngine.Keyframe[],UnityEngine.Keyframe[],UnityEngine.Keyframe[])">
            <summary>
            Create a Vector3Keyframes
            </summary>
            <param name="xKeys"> Keyframes for X component </param>
            <param name="yKeys"> Keyframes for Y component </param>
            <param name="zKeys"> Keyframes for Z component </param>
        </member>
        <member name="P:Skill.Animation.Vector3Keyframes.XKeys">
            <summary> Keyframes for X component </summary>
        </member>
        <member name="P:Skill.Animation.Vector3Keyframes.YKeys">
            <summary> Keyframes for Y component </summary>
        </member>
        <member name="P:Skill.Animation.Vector3Keyframes.ZKeys">
            <summary> Keyframes for Z component </summary>
        </member>
        <member name="T:Skill.AI.ActionCollection">
            <summary>
            Defines a collection of actions.
            </summary>
        </member>
        <member name="M:Skill.AI.ActionCollection.#ctor">
            <summary>
            Create an ActionCollection
            </summary>
        </member>
        <member name="M:Skill.AI.ActionCollection.Add(Skill.AI.Action)">
            <summary>
            Add new action to collection
            </summary>
            <param name="action">Action to add</param>
        </member>
        <member name="M:Skill.AI.ActionCollection.Remove(Skill.AI.Action)">
            <summary>
            Remove specified action from collection
            </summary>
            <param name="action">action to remove</param>
            <returns>True if action removed, otherwise false</returns>
        </member>
        <member name="M:Skill.AI.ActionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A System.Collections.Generic.IEnumerator;ltAction;gt that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Skill.AI.ActionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A System.Collections.Generic.IEnumerator lt;Action gt; that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Skill.AI.ActionCollection.Clear">
            <summary>
            Remove all actions from collection
            </summary>
        </member>
        <member name="M:Skill.AI.ActionCollection.Contains(Skill.AI.Action)">
            <summary>
            Determines whether the collection contains a specific Action.
            </summary>
            <param name="item">The Action to locate in the collection.</param>
            <returns>true if item is found in the collection; otherwise,false.</returns>
        </member>
        <member name="M:Skill.AI.ActionCollection.CopyTo(Skill.AI.Action[],System.Int32)">
            <summary>
            Copies the elements of the collection to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from collection. The System.Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
            array is multidimensional.  -or- arrayIndex is equal to or greater than the
            length of array.  -or- The number of elements in the source collection
            greater than the available space from arrayIndex to the end of the destination
            array. -or- Action cannot be cast automatically to the type of the destination array.
            </exception>
        </member>
        <member name="P:Skill.AI.ActionCollection.Item(System.Int32)">
            <summary>
            Retrieves Actions by index
            </summary>
            <param name="index">Zero based index of action</param>
            <returns>Action at given index</returns>
        </member>
        <member name="P:Skill.AI.ActionCollection.Count">
            <summary>
            Retrieves umber of actions in collection
            </summary>
        </member>
        <member name="P:Skill.AI.ActionCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
        </member>
        <member name="T:Skill.UI.ToggleButton">
            <summary>
            Make an on/off toggle button.
            </summary>
        </member>
        <member name="M:Skill.UI.ToggleButton.OnChecked">
            <summary>
            Occurs when a ToggleButton is checked.
            </summary>
        </member>
        <member name="M:Skill.UI.ToggleButton.OnUnchecked">
            <summary>
            Occurs when a ToggleButton is unchecked.
            </summary>
        </member>
        <member name="M:Skill.UI.ToggleButton.OnChanged">
            <summary>
            when a ToggleButton is Changed.
            </summary>
        </member>
        <member name="M:Skill.UI.ToggleButton.#ctor">
            <summary>
            Create an instance of ToggleButton
            </summary>
        </member>
        <member name="M:Skill.UI.ToggleButton.Render">
            <summary>
            Render ToggleButton
            </summary>
        </member>
        <member name="P:Skill.UI.ToggleButton.Content">
            <summary>
            Text, image and tooltip for this button.
            </summary>
        </member>
        <member name="P:Skill.UI.ToggleButton.IsChecked">
            <summary>
            Gets or sets whether the ToggleButton is checked.
            </summary>
        </member>
        <member name="E:Skill.UI.ToggleButton.Checked">
            <summary>
            Occurs when a ToggleButton is checked.
            </summary>
        </member>
        <member name="E:Skill.UI.ToggleButton.Unchecked">
            <summary>
            Occurs when a ToggleButton is unchecked.
            </summary>
        </member>
        <member name="E:Skill.UI.ToggleButton.Changed">
            <summary>
            Occurs when a ToggleButton is Changed.
            </summary>
        </member>
        <member name="T:Skill.UI.SelectionGrid">
            <summary>
            Make a grid of buttons.
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGrid.OnSelectedChanged">
            <summary>
            when selected item changed
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGrid.#ctor">
            <summary>
            Create an instance of SelectionGrid
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGrid.Render">
            <summary>
            Render SelectionGrid
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGrid.Items">
            <summary>
            Grid items
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGrid.SelectedIndex">
            <summary>
            Gets or sets Selected grid item index
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGrid.SelectedOption">
            <summary>
            Gets or sets Selected grid item
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGrid.XCount">
            <summary> How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</summary>
        </member>
        <member name="E:Skill.UI.SelectionGrid.SelectedChanged">
            <summary>
            Occurs when selected item changed
            </summary>
        </member>
        <member name="T:Skill.UI.RepeatButton">
            <summary>
            Make a button that is active as long as the user holds it down.
            </summary>
        </member>
        <member name="M:Skill.UI.RepeatButton.OnDown">
            <summary>
            when first time button is down
            </summary>
        </member>
        <member name="M:Skill.UI.RepeatButton.OnUp">
            <summary>
            when first time button is up
            </summary>
        </member>
        <member name="M:Skill.UI.RepeatButton.OnRepeat">
            <summary>
            each frame until it gets up
            </summary>
        </member>
        <member name="M:Skill.UI.RepeatButton.#ctor">
            <summary>
            Create an instance of RepeatButton
            </summary>
        </member>
        <member name="M:Skill.UI.RepeatButton.Render">
            <summary>
            Render RepeatButton
            </summary>
        </member>
        <member name="P:Skill.UI.RepeatButton.Content">
            <summary>
            Text, image and tooltip for this button.
            </summary>
        </member>
        <member name="E:Skill.UI.RepeatButton.Down">
            <summary>
            Occurs when first time button is down
            </summary>
        </member>
        <member name="E:Skill.UI.RepeatButton.Up">
            <summary>
            Occurs when first time button is up
            </summary>
        </member>
        <member name="E:Skill.UI.RepeatButton.Repeat">
            <summary>
            Occurs each frame until it gets up
            </summary>
        </member>
        <member name="T:Skill.Text.PersianCharacterForm">
            <summary>
            Defines forms that each persian character can take in a word
            </summary>
        </member>
        <member name="F:Skill.Text.PersianCharacterForm.Initial">
            <summary> Character is first character of word  </summary>
        </member>
        <member name="F:Skill.Text.PersianCharacterForm.Medial">
            <summary> Character is between and stick to beside characters in word  </summary>
        </member>
        <member name="F:Skill.Text.PersianCharacterForm.Final">
            <summary> Character is end character of word  </summary>
        </member>
        <member name="F:Skill.Text.PersianCharacterForm.Isolated">
            <summary> Character is whole word (is alone) </summary>
        </member>
        <member name="T:Skill.AI.ConditionHandler">
            <summary>
            Represents the method to handle execution of condition by user
            </summary>    
            <param name="parameters">Parameters for condition</param>
            <returns>true for success, false for failure</returns>
        </member>
        <member name="T:Skill.AI.Condition">
            <summary>
            Check that certain actor or game world states hold true.(leaf node)
            </summary>
        </member>
        <member name="M:Skill.AI.Condition.#ctor(System.String,Skill.AI.ConditionHandler)">
            <summary>
            Create an instance of Condition 
            </summary>
            <param name="name">Name of Behavior</param>
            <param name="handler">function to handle execution of action</param>
        </member>
        <member name="M:Skill.AI.Condition.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns></returns>
        </member>
        <member name="P:Skill.AI.Condition.Reverse">
            <summary>
            Reverse condition. (maybe remove latter)
            </summary>
        </member>
        <member name="T:Skill.AI.BehaviorTree">
            <summary>
            Base class of BehaviorTree that manage execution of Behaviors
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorTree.CreateTree">
            <summary>
            Implement by subclass to create tree hierarchy and return root node.
            </summary>
            <returns>Root node</returns>
        </member>
        <member name="M:Skill.AI.BehaviorTree.#ctor(Skill.Controllers.Controller)">
            <summary>
            Create an instance of BehaviorTree
            </summary>
            <param name="controller">The controller that using this BbehaviorTree.</param>
            <remarks>
            controller reserved for future version
            </remarks>
        </member>
        <member name="M:Skill.AI.BehaviorTree.OnUpdated">
            <summary> Call Updated event </summary>
        </member>
        <member name="M:Skill.AI.BehaviorTree.Update">
            <summary>
            Update Tree
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorTree.ForceUpdate">
            <summary>
            Force update tree even not reach UpdateTimeInterval
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorTree.Reset">
            <summary>
            Call this when your agent dies, destroyed, or whenever you do not need BehaviorTree
            this is important because sometimes maybe one Behavior node locked an AccessKey and could not unlock it before next update
            you have to call this to make sure other instance of BehaviorTree can access that AccessKey.
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorTree.Root">
            <summary>
            Root of Tree
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorTree.UpdateTimeInterval">
            <summary> 
            To enable update time interval set this to more than zero (default is 0.2f)
            still call updates each frame, tree reject it automatically
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorTree.Controller">
            <summary>
            The controller that using this BbehaviorTree
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorTree.UserData">
            <summary>
            User data
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorTree.State">
            <summary>
            State of BehaviorTree
            </summary>
        </member>
        <member name="E:Skill.AI.BehaviorTree.Updated">
            <summary> Occurs when Behavior Tree updated </summary>
        </member>
        <member name="T:Skill.UI.Window">
            <summary>
            Make a popup window.
            </summary>
        </member>
        <member name="T:Skill.UI.Frame">
            <summary>
            Frame is a content control that supports navigation.
            </summary>
        </member>
        <member name="M:Skill.UI.Frame.OnPositionChange">
            <summary>
            when position of control changed
            </summary>
        </member>
        <member name="M:Skill.UI.Frame.OnGUI">
            <summary>
            to render control you have to call this method in OnGUI method of MonoBehavior.(call this for Frame class)
            </summary>
        </member>
        <member name="M:Skill.UI.Frame.DrawControls">
            <summary>
            Call Grid.OnGUI() to draw controls
            </summary>
        </member>
        <member name="M:Skill.UI.Frame.#ctor">
            <summary>
            Initializes a new instance of the Frame class.
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.Position">
            <summary>
            Position of control relative to parent
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.X">
            <summary>
            Gets or sets Position.X
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.Y">
            <summary>
            Gets or sets Position.Y
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.Width">
            <summary>
            Gets or sets the suggested width of the element
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.Height">
            <summary>
            Gets or sets the suggested height of the element.
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.Name">
            <summary>
            Name of Frame. (optional)
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.Grid">
            <summary>
            Grid of Frame.
            </summary>
        </member>
        <member name="P:Skill.UI.Frame.FocusedControl">
            <summary>
            Get focused FocusableControl in last update or null if no FocusableControl got focus
            </summary>
        </member>
        <member name="E:Skill.UI.Frame.PositionChange">
            <summary> Occurs when position of control changed </summary>
        </member>
        <member name="P:Skill.UI.Frame.LocalGrid">
            <summary>
            Is grid rendered in local space of Frame.
            </summary>
        </member>
        <member name="M:Skill.UI.Window.#ctor">
            <summary>
            Create a window
            </summary>
        </member>
        <member name="M:Skill.UI.Window.DrawControls">
            <summary>
            Draw controls inside window
            </summary>
        </member>
        <member name="P:Skill.UI.Window.Id">
            <summary>
            A unique ID to use for each window. This is the ID you'll use to interface to.
            </summary>
        </member>
        <member name="P:Skill.UI.Window.IsDraggable">
            <summary>
            Whether the window Is draggable or not?
            </summary>
        </member>
        <member name="P:Skill.UI.Window.FullDraggable">
            <summary>
            True if you want to have the entire window background to act as a drag area, otherwise false to use DraggableArea
            </summary>
        </member>
        <member name="P:Skill.UI.Window.DraggableArea">
            <summary>
            the part of the window that can be dragged. This is clipped to the actual window.
            </summary>
        </member>
        <member name="P:Skill.UI.Window.Title">
            <summary>
            Title of window
            </summary>
        </member>
        <member name="P:Skill.UI.Window.Style">
            <summary>
            The style to use. If null, the style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.UI.Window.LocalGrid">
            <summary>
            Grid rendered in local space
            </summary>
        </member>
        <member name="T:Skill.UI.Size">
            <summary>
            Implements a structure that is used to describe the Size of an object.
            </summary>
        </member>
        <member name="M:Skill.UI.Size.op_Equality(Skill.UI.Size,Skill.UI.Size)">
            <summary>
            Compares two instances of Size for equality.
            </summary>
            <param name="size1">The first instance of Skill.UI.Size to compare.</param>
            <param name="size2"> The second instance of Skill.UI.Size to compare.</param>
            <returns>true if the two instances of Skill.UI.Size are equal; otherwise false.</returns>
        </member>
        <member name="M:Skill.UI.Size.op_Inequality(Skill.UI.Size,Skill.UI.Size)">
            <summary>
            Compares two instances of Skill.UI.Size for inequality.
            </summary>
            <param name="size1">The first instance of Skill.UI.Size to compare.</param>
            <param name="size2">The second instance of Skill.UI.Size to compare.</param>
            <returns>true if the instances of Skill.UI.Size are not equal; otherwise false.</returns>
        </member>
        <member name="M:Skill.UI.Size.Equals(Skill.UI.Size,Skill.UI.Size)">
            <summary>
            
            </summary>
            <param name="size1"></param>
            <param name="size2"></param>
            <returns></returns>
        </member>
        <member name="M:Skill.UI.Size.Equals(System.Object)">
            <summary>
            Compares an object to an instance of Skill.UI.Size for equality.
            </summary>
            <param name="o">The System.Object to compare.</param>
            <returns>true if the sizes are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.UI.Size.Equals(Skill.UI.Size)">
            <summary>
            Compares a value to an instance of Skill.UI.Size for equality.
            </summary>
            <param name="value">The size to compare to this current instance of Skill.UI.Size.</param>
            <returns>true if the instances of Skill.UI.Size are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.UI.Size.GetHashCode">
            <summary>
            Gets the hash code for this instance of Skill.UI.Size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.UI.Size.ToString">
            <summary>
             The hash code for this instance of Skill.UI.Size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.UI.Size.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the Skill.UI.Size structure and assigns it an initial width and height.
            </summary>
            <param name="width">The initial width of the instance of Skill.UI.Size.</param>
            <param name="height">The initial height of the instance of Skill.UI.Size.</param>
        </member>
        <member name="M:Skill.UI.Size.op_Explicit(Skill.UI.Size)~UnityEngine.Vector2">
            <summary>
            Convet a Size to a UnityEngine.Vector2
            </summary>
            <param name="size">size to convert</param>
            <returns>Size</returns>
        </member>
        <member name="M:Skill.UI.Size.op_Explicit(UnityEngine.Vector2)~Skill.UI.Size">
            <summary>
            Convet a UnityEngine.Vector2 to a Size
            </summary>
            <param name="vector"> vector to convert </param>
            <returns>Skill.UI.Size</returns>
        </member>
        <member name="P:Skill.UI.Size.Empty">
            <summary>
            Empty size
            </summary>
        </member>
        <member name="P:Skill.UI.Size.IsEmpty">
            <summary>
            Gets a value that represents a static empty Skill.UI.Size.
            </summary>
        </member>
        <member name="P:Skill.UI.Size.Width">
            <summary>
            Gets or sets the Skill.UI.Size.Width of this instance of Skill.UI.Size.
            </summary>
            <returns>
            The Skill.UI.Size.Width of this instance of Skill.UI.Size. The default value is 0. The value cannot be negative.
            </returns>
        </member>
        <member name="P:Skill.UI.Size.Height">
            <summary>
            Gets or sets the Skill.UI.Size.Height of this instance of Skill.UI.Size.
            </summary>
            <returns> The Skill.UI.Size.Height of this instance of Skill.UI.Size. The default is 0. The value cannot be negative. </returns>
        </member>
        <member name="T:Skill.Text.PersianCharacterMap">
            <summary>
            Default PersianCharacterMap 
            </summary>
        </member>
        <member name="M:Skill.Text.PersianCharacterMap.UseFirstNumerics">
            <summary>
            Use first set of persian characters in unicode ( '\u0660', '\u0661', ... , '\u0669' )
            </summary>
        </member>
        <member name="M:Skill.Text.PersianCharacterMap.UseSecondNumerics">
            <summary>
            Use second set of persian characters in unicode ( '\u06F0', '\u06F1', ... , '\u06F9' )
            </summary>
        </member>
        <member name="M:Skill.Text.PersianCharacterMap.#ctor">
            <summary>
            Create a PersianCharacterMap
            </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Map">
            <summary>
            A dictionary that maps each word to equivalent persian character
            </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Alef">
            <summary> الف </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Beh">
            <summary> ب </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Peh">
            <summary> پ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Teh">
            <summary> ت </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Theh">
            <summary> ث </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Jeem">
            <summary> ج </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Cheh">
            <summary> چ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Hah">
            <summary> ح </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Khah">
            <summary> خ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Dal">
            <summary> د </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Thal">
            <summary> ذ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Reh">
            <summary> ر </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Zain">
            <summary> ز </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Jeh">
            <summary> ژ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Seen">
            <summary> س </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Sheen">
            <summary> ش </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Sad">
            <summary> ص </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Dad">
            <summary> ض </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Tah">
            <summary> ط </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Zah">
            <summary> ظ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Ain">
            <summary> ع </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Ghain">
            <summary> غ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Feh">
            <summary> ف </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Qaf">
            <summary> ق </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Kaf">
            <summary> ک </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Gaf">
            <summary> گ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Lam">
            <summary> ل </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Meem">
            <summary> م </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Noon">
            <summary> ن </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Waw">
            <summary> و </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Heh">
            <summary> ه </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Yeh">
            <summary> ی </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Zero">
            <summary> 0 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.One">
            <summary> 1 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Two">
            <summary> 2 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Three">
            <summary> 3 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Four">
            <summary> 4 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Five">
            <summary> 5 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Six">
            <summary> 6 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Seven">
            <summary> 7 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Eight">
            <summary> 8 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Nine">
            <summary> 9 </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Fathatan">
            <summary> اً </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Dammatan">
            <summary> اٌ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Kasratan">
            <summary> اٍ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Fatha">
            <summary> اَ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Damma">
            <summary> اُ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Kasra">
            <summary> اِ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Shadda">
            <summary> اّ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.RialSign">
            <summary> ريال </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Comma">
            <summary> ، </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Semicolon">
            <summary> ؛ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.AlefMadda">
            <summary> آ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.WawWithHamzaAbove">
            <summary> ؤ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.AlefWithHamzaAbove">
            <summary> أ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.AlefWithHamzaBelow">
            <summary> إ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Hamza">
            <summary> ء </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.QuestionMark">
            <summary> ؟ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.Tatweel">
            <summary> ـ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.LeftParenthesis">
            <summary> ( </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.RightParenthesis">
            <summary> ) </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.YehWithHamzaAbove">
            <summary> ئ </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.LigatureLam">
            <summary> لا </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacterMap.LigatureAllah">
            <summary> الله </summary>
        </member>
        <member name="T:Skill.UI.Grid">
            <summary>
            Defines a flexible grid area that consists of columns and rows.
            </summary>
        </member>
        <member name="M:Skill.UI.Grid.#ctor">
            <summary>
            Initializes a new instance of Grid.        
            </summary>
        </member>
        <member name="M:Skill.UI.Grid.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.UI.Grid.ColumnDefinitions">
            <summary>
            Gets a ColumnDefinitionCollection defined on this instance of Grid.
            </summary>        
        </member>
        <member name="P:Skill.UI.Grid.RowDefinitions">
            <summary>
            Gets a RowDefinitionCollection defined on this instance of Grid.
            </summary>    
        </member>
        <member name="T:Skill.UI.ControlType">
            <summary>
            Types of Controls
            </summary>
        </member>
        <member name="F:Skill.UI.ControlType.Control">
            <summary>
            Controls that hosted by panels
            </summary>
        </member>
        <member name="F:Skill.UI.ControlType.Panel">
            <summary>
            Panels that contains another Controls
            </summary>
        </member>
        <member name="T:Skill.UI.BaseControlCollection">
            <summary>
            Defines methods to manipulate collection of BaseControls.
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.OnLayoutChange">
            <summary>
            when any Control insid collection needs to update it's layout
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.#ctor(Skill.UI.Panel)">
            <summary>
            Create a BaseControlCollection
            </summary>
            <param name="panel"> Panel that use this collection</param>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.Add(Skill.UI.BaseControl)">
            <summary>
            Adds an BaseControl to the Collection.
            </summary>
            <param name="control"> The BaseControl to add to Collection </param>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.Clear">
            <summary>
            Removes all Controls from the collection
            </summary>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.Contains(Skill.UI.BaseControl)">
            <summary>
            Determines whether the collection contains a specific Control
            </summary>
            <param name="control">The Cotrol to locate in collection</param>
            <returns> true if Control is found in the collection; otherwise, false.</returns>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.CopyTo(Skill.UI.BaseControl[],System.Int32)">
            <summary>
            Copies the elements of the collection to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">The one-dimensional System.Array that is the destination of the elements
            copied from collection. The System.Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
            array is multidimensional.-or-The number of elements in the source collection
            is greater than the available space from arrayIndex to the end of the destination
            array.-or-Type T cannot be cast automatically to the type of the destination array.
            </exception>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.Remove(Skill.UI.BaseControl)">
            <summary>
            Removes  the first occurrence of a specific control from the collection.
            </summary>
            <param name="control"> The BaseControl to remove from the collection </param>
            <returns>
            true if item was successfully removed from the collection otherwise, false.
            This method also returns false if item is not found in the original collection
            </returns>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltBaseControl;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.BringToFront(Skill.UI.BaseControl)">
            <summary>
            Attempts to bring this element to front.
            </summary>
            <param name="control">BaseControl to bring to front</param>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.BringToBack(Skill.UI.BaseControl)">
            <summary>
            Attempts to bring this element to back.
            </summary>
            <param name="control">BaseControl to bring to back</param>
        </member>
        <member name="M:Skill.UI.BaseControlCollection.IndexOf(Skill.UI.BaseControl)">
            <summary>
            Searches for the specified BaseControl and returns the zero-based index of the first occurrence within the entire Controls.
            </summary>
            <param name="control">The BaseControl to locate in the Controls.</param>
            <returns>
            The zero-based index of the first occurrence of item within the entire Controls, if found; otherwise, –1.
            </returns>
        </member>
        <member name="E:Skill.UI.BaseControlCollection.LayoutChange">
            <summary>
             Occurs when any Control insid collection needs to update it's layout
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControlCollection.Panel">
            <summary>
            Panel that use this collection
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControlCollection.Item(System.Int32)">
            <summary>
            Retrieves controls by index
            </summary>
            <param name="index">index of control</param>
            <returns>Control at specified index</returns>
        </member>
        <member name="P:Skill.UI.BaseControlCollection.Count">
            <summary>
            Gets the number of Controls contained in the collection.
            </summary>
        </member>
        <member name="P:Skill.UI.BaseControlCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimationLayer">
            <summary>
            Manage animation blending of single layer
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimationLayer.#ctor(System.Int32,UnityEngine.AnimationBlendMode)">
            <summary>
            Create an instance of AnimationLayer
            </summary>
            <param name="layerIndex">Index of layer</param>
            <param name="blendMode">AnimationBlendMode</param>
        </member>
        <member name="M:Skill.Animation.AnimationLayer.BeginUpdate">
            <summary>
            Prepare for update
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimationLayer.Update">
            <summary>
            Update Layer
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimationLayer.UpdateAnimation(Skill.Animation.AnimNodeSequence)">
            <summary>
            Make sure given AnimNodeSequence will update at next update
            </summary>
            <param name="anim">AnimNodeSequence to update</param>
        </member>
        <member name="M:Skill.Animation.AnimationLayer.AddToActiveList(Skill.Animation.AnimNodeSequence)">
            <summary>
            Register given AnimNodeSequence to process next update
            </summary>
            <param name="anim"></param>
        </member>
        <member name="M:Skill.Animation.AnimationLayer.CleanUpActiveList">
            <summary>
            Remove AnimNodeSequences with weight == 0
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimationLayer.Apply(UnityEngine.Animation)">
            <summary>
            Apply changes to UnityEngine.Animation component 
            </summary>
            <param name="animationComponent">UnityEngine.Animation to apply changes to</param>
        </member>
        <member name="P:Skill.Animation.AnimationLayer.ActiveAnimNodes">
            <summary>
            include AnimNodes with weight > 0
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationLayer.LayerIndex">
            <summary>
            Index of layer. (begin by 0)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationLayer.BlendMode">
            <summary>
            AnimationBlendMode. (Blend or Additive)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationLayer.RootMotion">
            <summary>
            RootMotion result of Sequences in this layer
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeBlendBySpeed">
            <summary>
            This blend node allows the Anim Tree to automatically blend between inputs between the constraints based on the size of the Velocity or Acceleration vector within the owning actor.
            The constraints define the bounds between each input, 
            for example, Constraints[0] and Constraints[1] define the lower and upper bound for index 0;
            Constraints[1] and Constraints[2] define the lower and upper bound for index 1; and so forth.
            These bounds are modified by the Blend Down Perc value, set Blend Down Perc to zero if you wish to keep the bounds strict.
            http://udn.epicgames.com/Three/AnimationNodes.html#AnimNodeBlendBySpeed
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendBySpeed.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeBlendBySpeed
            </summary>
            <param name="childCoun">number of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendBySpeed.CalcBlendWeights(System.Single[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.Velocity">
            <summary>
            Get or set velocity of actor
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.BlendUpTime">
            <summary>
            How fast to blend when going up an index.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.BlendDownTime">
            <summary>
            How fast to blend when going down an index.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.BlendDownPercent">
            <summary>
            Where abouts in the constraint bounds should the blend start blending down.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.BlendUpDelay">
            <summary>
            Time delay before blending up an index.
            </summary> 
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.BlendDownDelay">
            <summary>
            Time delay before blending down an index.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.Constraints">
            <summary> Constraints </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendBySpeed.ConstraintCount">
            <summary> Number of constraints (ChildCount + 1)</summary>
        </member>
        <member name="T:Skill.TimeWatch">
            <summary>
            Helper class for track limitation of a job
            </summary>
        </member>
        <member name="M:Skill.TimeWatch.Begin(System.Single,System.Boolean)">
            <summary>
            Begin timer 
            </summary>
            <param name="length">Lenght of timer</param>
            <param name="useRealTime">if true TimeWatch use Time.realtimeSinceStartup instead of Time.time</param>
        </member>
        <member name="M:Skill.TimeWatch.End">
            <summary>
            End
            </summary>
        </member>
        <member name="P:Skill.TimeWatch.StartTime">
            <summary>
            Start time
            </summary>
        </member>
        <member name="P:Skill.TimeWatch.OverTime">
            <summary>
            End time
            </summary>
        </member>
        <member name="P:Skill.TimeWatch.Length">
            <summary>
            Get and set Length
            </summary>
        </member>
        <member name="P:Skill.TimeWatch.Enabled">
            <summary>
            Is enabled (begined)
            </summary>
        </member>
        <member name="P:Skill.TimeWatch.EnabledAndOver">
            <summary>
            Is enabled (begined) and current time is greater than OverTime
            </summary>
        </member>
        <member name="P:Skill.TimeWatch.IsOver">
            <summary>
            Whether current time is greater than OverTime
            </summary>
        </member>
        <member name="P:Skill.TimeWatch.UseRealTime">
            <summary>
            if true TimeWatch use Time.realtimeSinceStartup instead of Time.time
            </summary>
        </member>
        <member name="T:Skill.Managers.EventManager">
            <summary>    
            This class designed to avoid using SendMessage. 
            </summary>    
            <remarks>
            i think SenMessage can be expensive because it must use reflection to know which behavior has requested method
            so i use this way to call methods on MonoBehaviors. this needs more work to do
            each game must defines it's own EventManager
            </remarks>
            <example> for example    
            <code>
            public class ThisGameEventManager : EventManager
            {
                public delegate void OnHitHandler(UnityEngine.Collider other);   
                public event OnHitHandler Hit;    
                    
                public void OnHit(UnityEngine.Collider other)
                {
                    if (Hit != null)
                        Hit(other);
                }
            }
            
            public class PLayer : Skill.Controllers.Controller, Skill.Managers.IEventManagerHooker
            {
            
                void Awake()
                {
                    HookEvents();
                }
            
                void OnDestroy()
                {
                    UnhookEvents();
                }
            
                public void HookEvents()
                {
                    _OnHitHandler = OnHit;
            
                    ThisGameEventManager eventManager = ThisGameEventManager.Get;ltThisGameEventManager;gt(this.gameObject);
                    if (eventManager != null)
                    {                
                        eventManager.Hit += _OnHitHandler;
                    }
                }
            
                public void UnhookEvents()
                {
                    ThisGameEventManager eventManager = ThisGameEventManager.Get;ltThisGameEventManager;gt(this.gameObject);
                    if (eventManager != null)
                    {
                        eventManager.Hit -= _OnHitHandler;
                    }
                }
                
                private ThisGameEventManager.OnHitHandler _OnHitHandler;
                private void OnHit(UnityEngine.Collider other)
                {
                    // do something
                }
            }    
            </code>
            
            other behaviors could call OnHit method to notify interested behaviors
            </example>          
        </member>
        <member name="M:Skill.Managers.EventManager.Get``1(UnityEngine.GameObject)">
            <summary>
            Get specified EventManager
            </summary>
            <typeparam name="T">type of EventManager</typeparam>
            <param name="go">GameObject to retrieve EventManager</param>
            <returns>EventManager</returns>
        </member>
        <member name="M:Skill.Managers.EventManager.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="T:Skill.Managers.HitHandler">
            <summary>
            Handle a ray or somthing Hit this GameObject
            </summary>
            <param name="other">The collider that hit by this gameobject</param>
            <param name="userData">custom userdata</param>
        </member>
        <member name="T:Skill.Managers.DefaultHandler">
            <summary>
            Handle this agent is dead
            </summary>    
            <param name="userData">custom userdata</param>
        </member>
        <member name="T:Skill.Managers.DefaultEventManager">
            <summary>
            Implement some common events
            </summary>
        </member>
        <member name="M:Skill.Managers.DefaultEventManager.OnHit(UnityEngine.Collider,System.Object)">
            <summary>
            Call this method to notify all Components in GameObject about hitting something
            </summary>
            <param name="other">The collider that hit by this gameobject</param>
            <param name="userData">custom userdata</param>
        </member>
        <member name="M:Skill.Managers.DefaultEventManager.OnDie(System.Object)">
            <summary>
            Call this method to notify all Components in GameObject that this agent is dead
            </summary>        
            <param name="userData">custom userdata</param>
        </member>
        <member name="E:Skill.Managers.DefaultEventManager.Hit">
            <summary>
            Occurs when a ray or somthing Hit this GameObject
            </summary>
        </member>
        <member name="E:Skill.Managers.DefaultEventManager.Die">
            <summary>
            Occurs when this GameObject is dead
            </summary>
        </member>
        <member name="T:Skill.Animation.RootMotionState">
            <summary>
            Specify how to update RootMotion
            </summary>
        </member>
        <member name="P:Skill.Animation.RootMotionState.PositionX">
            <summary> PositionX is enable or not? </summary>
        </member>
        <member name="P:Skill.Animation.RootMotionState.PositionY">
            <summary> PositionY is enable or not? </summary>
        </member>
        <member name="P:Skill.Animation.RootMotionState.PositionZ">
            <summary> PositionZ is enable or not? </summary>
        </member>
        <member name="P:Skill.Animation.RootMotionState.IsEnable">
            <summary>
            Whether at least one of parameters is enable
            </summary>
        </member>
        <member name="T:Skill.Animation.RootMotion">
            <summary>
            RootMotion of AnimationSequence
            </summary>
        </member>
        <member name="M:Skill.Animation.RootMotion.SetKeyframes(Skill.Animation.Vector3Keyframes)">
            <summary>
            Set Keyframes
            </summary>
            <param name="keys">Position Keyframes</param>
        </member>
        <member name="M:Skill.Animation.RootMotion.#ctor(Skill.Animation.AnimNodeSequence)">
            <summary>
            Create a RootMotion
            </summary>
            <param name="sequence">Owner Sequence</param>
        </member>
        <member name="M:Skill.Animation.RootMotion.Begin">
            <summary>
            Begin calculatin RootMotion (when Sequence became relevant)
            </summary>
        </member>
        <member name="M:Skill.Animation.RootMotion.End">
            <summary>
            End calculatin RootMotion (when Sequence Cease relevant)
            </summary>
        </member>
        <member name="M:Skill.Animation.RootMotion.Evaluate">
            <summary>
            Evaluate curves and calculate motion between two updates
            </summary>
        </member>
        <member name="P:Skill.Animation.RootMotion.Motion">
            <summary> Motion in current update </summary>
        </member>
        <member name="P:Skill.Animation.RootMotion.State">
            <summary> Whether RootMotion is enable or not? </summary>
        </member>
        <member name="T:Skill.UI.Visibility">
            <summary>
            Specifies the display state of an element.
            </summary>
        </member>
        <member name="F:Skill.UI.Visibility.Visible">
            <summary>
            Display the element.
            </summary>
        </member>
        <member name="F:Skill.UI.Visibility.Hidden">
            <summary>
            Do not display the element, but reserve space for the element in layout.
            </summary>
        </member>
        <member name="F:Skill.UI.Visibility.Collapsed">
            <summary>
            Do not display the element, and do not reserve space for it in layout.
            </summary>
        </member>
        <member name="T:Skill.UI.StackPanel">
            <summary>
            Arranges child elements into a single line that can be oriented horizontally or vertically.    
            </summary>
        </member>
        <member name="M:Skill.UI.StackPanel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="M:Skill.UI.StackPanel.#ctor">
            <summary>
            Create an instance of StackPanel
            </summary>
        </member>
        <member name="P:Skill.UI.StackPanel.Orientation">
            <summary>
            Gets or sets a value that indicates the dimension by which child elements are stacked.
            </summary>       
        </member>
        <member name="T:Skill.Animation.AnimNodeSequence">
            <summary>
            This animation node outputs the animation data within an animation sequence.
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeSequence.UpdatePreviousAnimation">
            <summary>
            whether animation layer needs to update PreviousAnimation. when AnimationTree profile changed
            </summary>
        </member>
        <member name="F:Skill.Animation.AnimNodeSequence.RelevantTime">
            <summary>
            Specify when this animation bacame relevant, and when needs to finish
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.UpdateAnimation">
            <summary>
            Update AnimationName and Format and check whether it needs to update previous animation
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.#ctor">
            <summary>
            Create an instance of AnimNodeSequence
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.#ctor(System.String)">
            <summary>
            Create an instance of AnimNodeSequence
            </summary>
            <param name="animationName">Name of AnimationClip</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.OnBecameRelevant(Skill.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.OnCeaseRelevant(Skill.Animation.AnimationTreeState)">
            <summary>
            call CeaseRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.Blend">
            <summary>
            update weight
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.SelectLayer(Skill.Animation.AnimationLayerManager,Skill.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.SetFormat(System.String)">
            <summary>
            Set format of aimation name
            </summary>
            <param name="format"></param>
        </member>
        <member name="M:Skill.Animation.AnimNodeSequence.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize and collect information from animationComponent
            </summary>
            <param name="animationComponent">UnityEngine.Animation</param>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.IgnoreMissAnimationWarning">
            <summary>
            by default skill generates warnings for miss animations. set it true to disable warnings.
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.PreviousAnimation">
            <summary>
            Previous AnimationName
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.AnimationName">
            <summary>
            Name of AnimationClip
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.Format">
            <summary>
            Format of AnimationName. used in AnimationTree profile
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.CurrentAnimation">
            <summary>
            Current Animation Name
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.UseTreeProfile">
            <summary>
            Whether use AnimationTree profiling method? (default is true)
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.MixingTransforms">
            <summary> MixingTransforms </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.Synchronize">
            <summary>
            Synchronize animations with other animations in same Layer?
            </summary>
            <remarks>
            it can be used for Direction AnimationClips that has same length.
            </remarks>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.Speed">
            <summary>
            Speed at which the animation will be played back. Default is 1.0
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.WrapMode">
            <summary>
            WrapMode
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.Layer">
            <summary>
            Layer
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.Length">
            <summary>
            Lenght of AnimationClip based on speed
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeSequence.RootMotion">
            <summary> RootMotion data </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeAdditiveBlending">
            <summary>
            This blend node allows the Anim Tree to combine additive animation, or a blend of additive animations.    
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAdditiveBlending.#ctor">
            <summary>
            Create an insatance of AnimNodeAdditiveBlending
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeAdditiveBlending.CalcBlendWeights(System.Single[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeAdditiveBlending.SelectLayer(Skill.Animation.AnimationLayerManager,Skill.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="P:Skill.Animation.AnimNodeAdditiveBlending.AdditiveWeight">
            <summary>
            Weight of AdditiveLayer
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAdditiveBlending.IsAdditive">
            <summary>
            Whether additive layer is enable?
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAdditiveBlending.NormalNode">
            <summary>
            The AnimNode that use input blendmode specified by parent
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAdditiveBlending.AdditiveNode">
            <summary>
            The AnimNode that use additive blendmode
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeAdditiveBlending.Length">
            <summary>
            Retrives lenght of active sub branch.
            </summary>
        </member>
        <member name="T:Skill.AI.PriorityType">
            <summary>
            Defines behavior of PrioritySelector
            </summary>
        </member>
        <member name="F:Skill.AI.PriorityType.HighestPriority">
            <summary>
            Allways  begin by high priority node
            </summary>
        </member>
        <member name="F:Skill.AI.PriorityType.RunningNode">
            <summary>
            Continue by last running node
            </summary>
        </member>
        <member name="T:Skill.AI.PrioritySelector">
            <summary>
            On each traversal priority selectors check which child to run in priority order until the first one succeeds or returns that it is running.
            One option is to call the last still running node again during the next behavior tree update. The other option is to always restart traversal
            from the highest priority child and implicitly cancel the last running child behavior if it isn’t chosen immediately again.
            </summary>
        </member>
        <member name="M:Skill.AI.PrioritySelector.#ctor(System.String)">
            <summary>
            Create an instance of PrioritySelector
            </summary>
            <param name="name">Name of Behavior</param>
        </member>
        <member name="M:Skill.AI.PrioritySelector.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="P:Skill.AI.PrioritySelector.Priority">
            <summary>
            Behavior of PrioritySelector (default : HighestPriority)
            </summary>
        </member>
        <member name="P:Skill.AI.PrioritySelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="T:Skill.Managers.CacheGroup">
            <summary>
            Group of CacheObjects for better management
            </summary>
        </member>
        <member name="F:Skill.Managers.CacheGroup.Caches">
            <summary> CacheObjects </summary>
        </member>
        <member name="F:Skill.Managers.CacheGroup.CleanInterval">
            <summary> Clean Interval of this group</summary>
        </member>
        <member name="M:Skill.Managers.CacheGroup.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Managers.CacheGroup.OnDestroy">
            <summary>
            On Destroy
            </summary>
        </member>
        <member name="M:Skill.Managers.CacheGroup.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.IO.ISavable.Save(System.Xml.XmlElement,Skill.IO.XmlSaveStream)">
            <summary>
            Save data to given XmlElement e
            </summary>
            <param name="e">XmlElement to save data in</param>
            <param name="stream">helper stream</param>        
        </member>
        <member name="M:Skill.IO.ISavable.Save(Skill.IO.BinarySaveStream)">
            <summary>
            Save data to given stream
            </summary>
            <param name="stream">Stream to save data</param>
        </member>
        <member name="M:Skill.IO.ISavable.Load(System.Xml.XmlElement,Skill.IO.XmlLoadStream)">
            <summary>
            Load data from given XmlElement e
            </summary>
            <param name="e">XmlElement that containes data</param>
            <param name="stream">Helper stream</param>
        </member>
        <member name="M:Skill.IO.ISavable.Load(Skill.IO.BinaryLoadStream)">
            <summary>
            Load data from given stream
            </summary>
            <param name="stream">Stream to load data from</param>
        </member>
        <member name="T:Skill.UI.WrapPanel">
            <summary>
            Positions child elements in sequential position from left to right, breaking
            content to the next line at the edge of the containing box. Subsequent ordering
            happens sequentially from top to bottom or from right to left, depending
            on the value of the WrapPanel.Orientation property.
            </summary>
        </member>
        <member name="M:Skill.UI.WrapPanel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.UI.WrapPanel.Orientation">
            <summary>
            Gets or sets a value that specifies the dimension in which child content is arranged.
            </summary> 
            <returns>
             An Orientation value that represents the physical orientation of content within the WrapPanel as horizontal or vertical.
             The default value is Orientation.Horizontal.
            </returns>
        </member>
        <member name="T:Skill.UI.UniformGrid">
            <summary>
            Provides a way to arrange content in a grid where all the cells in the grid have the same size.
            </summary>
        </member>
        <member name="M:Skill.UI.UniformGrid.#ctor">
            <summary>
            Initializes a new instance of the UniformGrid class.
            </summary>
        </member>
        <member name="M:Skill.UI.UniformGrid.UpdateLayout">
            <summary>
             Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.UI.UniformGrid.Columns">
            <summary> Gets or sets the number of columns that are in the grid. </summary>
        </member>
        <member name="P:Skill.UI.UniformGrid.Rows">
            <summary> Gets or sets the number of rows that are in the grid. </summary>
        </member>
        <member name="T:Skill.UI.Toolbar">
            <summary>
            Make a toolbar
            </summary>
        </member>
        <member name="M:Skill.UI.Toolbar.#ctor">
            <summary>
            Create a Toolbar
            </summary>
        </member>
        <member name="M:Skill.UI.Toolbar.Render">
            <summary>
            Render Toolbar
            </summary>
        </member>
        <member name="P:Skill.UI.Toolbar.Items">
            <summary>
            Toolbar buttons
            </summary>
        </member>
        <member name="P:Skill.UI.Toolbar.SelectedIndex">
            <summary>
            gets or sets selected button index
            </summary>
        </member>
        <member name="P:Skill.UI.Toolbar.SelectedOption">
            <summary>
            gets or sets selected button
            </summary>
        </member>
        <member name="T:Skill.UI.ScrollView">
            <summary>
            Make a scrolling view inside your GUI.
            </summary>
        </member>
        <member name="M:Skill.UI.ScrollView.#ctor">
            <summary>
            Create an instance of ScrollView
            </summary>
        </member>
        <member name="M:Skill.UI.ScrollView.BeginRender">
            <summary> Begin Render control's content </summary>
        </member>
        <member name="M:Skill.UI.ScrollView.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.HorizontalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.VerticalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.ScrollPosition">
            <summary>
            The pixel distance that the view is scrolled in the X and Y directions.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.ScrollX">
            <summary>
            The pixel distance that the view is scrolled in the X direction.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.ScrollY">
            <summary>
            The pixel distance that the view is scrolled in the Y direction.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.ViewRect">
            <summary>
            The rectangle used inside the scrollview.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.AlwayShowHorizontal">
            <summary>
            Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when clientRect is wider than position.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.AlwayShowVertical">
            <summary>
            Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when clientRect is taller than position.
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.HandleScrollWheel">
            <summary>
            Optional parameter to handle ScrollWheel
            </summary>
        </member>
        <member name="P:Skill.UI.ScrollView.ScrollbarThickness">
            <summary>
            Gets or sets thikness of vertical scrollbar to consider when calculating scrollview area (default is 16)
            </summary>
        </member>
        <member name="T:Skill.UI.RowDefinition">
            <summary>
            Defines row-specific properties that apply to Grid elements.
            </summary>
        </member>
        <member name="M:Skill.UI.RowDefinition.#ctor">
            <summary>
            Initializes a new instance of the RowDefinition class.
            </summary>
        </member>
        <member name="P:Skill.UI.RowDefinition.Height">
            <summary>
             Gets the calculated height of a RowDefinition element,
             or sets the GridLength value of a column that is defined by the RowDefinition.
            </summary>
        </member>
        <member name="P:Skill.UI.RowDefinition.MaxHeight">
            <summary>
            Gets or sets a value that represents the maximum height of a RowDefinition.
            </summary>
        </member>
        <member name="P:Skill.UI.RowDefinition.MinHeight">
            <summary>
            Gets or sets a value that represents the minimum height of a RowDefinition.
            </summary>
        </member>
        <member name="T:Skill.UI.RowDefinitionCollection">
            <summary>
            Provides access to an ordered, strongly typed collection of RowDefinition objects.
            </summary>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.#ctor">
            <summary>
            Create a instance of RowDefinitionCollection class
            </summary>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.Add(Skill.UI.RowDefinition)">
            <summary>
            Adds a RowDefinition element to a RowDefinitionCollection.
            </summary>
            <param name="value">Identifies the RowDefinition to add to the collection.</param>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.Clear">
            <summary>
            Clears the content of the RowDefinitionCollection.
            </summary>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.Contains(Skill.UI.RowDefinition)">
            <summary>
            Determines whether a given RowDefinition exists within a RowDefinitionCollection.
            </summary>
            <param name="value"> Identifies the RowDefinition that is being tested. </param>
            <returns>true if the RowDefinition exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.CopyTo(Skill.UI.RowDefinition[],System.Int32)">
            <summary>
             Copies an array of RowDefinition objects to a given index position within a RowDefinitionCollection.
            </summary>
            <param name="array"> An array of RowDefinition objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the RowDefinition objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.Remove(Skill.UI.RowDefinition)">
            <summary>
            Removes a RowDefinition from a RowDefinitionCollection.
            </summary>
            <param name="value"> The RowDefinition to remove from the collection. </param>
            <returns> true if the RowDefinition was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltRowDefinition;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.UI.RowDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="P:Skill.UI.RowDefinitionCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a RowDefinitionCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="E:Skill.UI.RowDefinitionCollection.Change">
            <summary>
            Occurs when any changes happens to collection (Add, Remove, Clear)
            </summary>
        </member>
        <member name="P:Skill.UI.RowDefinitionCollection.Count">
            <summary>
            Gets the total number of items within this instance of RowDefinitionCollection.
            </summary>
        </member>
        <member name="P:Skill.UI.RowDefinitionCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a RowDefinitionCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Text.PersianCharacter">
            <summary>
            Defines all forms of a persian character
            </summary>
        </member>
        <member name="M:Skill.Text.PersianCharacter.#ctor(System.Char,System.Char,System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Create a PersianCharacter
            </summary>
            <param name="initial">Character in Initial form</param>
            <param name="medial">Character in Medial form</param>
            <param name="final">Character in Final form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Text.PersianCharacter.#ctor(System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Create a PersianCharacter
            </summary>        
            <param name="final">Character in Final (also Initial and Medial) form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Text.PersianCharacter.#ctor(System.Char)">
            <summary>
            Create a PersianCharacter
            </summary>                
            <param name="isolated">Character in Isolated ( also Initial, Medial and Final) form</param>        
        </member>
        <member name="M:Skill.Text.PersianCharacter.SetData(System.Char,System.Char,System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Set all properties in one call
            </summary>
            <param name="initial">Character in Initial form</param>
            <param name="medial">Character in Medial form</param>
            <param name="final">Character in Final form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Text.PersianCharacter.SetData(System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Set all properties in one call
            </summary>        
            <param name="final">Character in Final (also Initial and Medial) form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Text.PersianCharacter.SetData(System.Char)">
            <summary>
            Set all properties in one call
            </summary>                
            <param name="isolated">Character in Isolated ( also Initial, Medial and Final) form</param>  
        </member>
        <member name="M:Skill.Text.PersianCharacter.Contains(System.Char)">
            <summary>
            Whether specified character is any form of persian character
            </summary>
            <param name="c">Character to check</param>
            <returns>True if specified character is one form of persian character, otherwise false.</returns>
        </member>
        <member name="P:Skill.Text.PersianCharacter.InitialForm">
            <summary> Gets or sets Character in Initial form </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacter.MedialForm">
            <summary> Gets or sets Character in Medial form </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacter.FinalForm">
            <summary> Gets or sets Character in Final form </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacter.IsolatedForm">
            <summary> Gets or sets Character in Isolated form </summary>
        </member>
        <member name="P:Skill.Text.PersianCharacter.CanStickToPrevious">
            <summary> Whether this persian character can stick to previous character.</summary>
            <remarks>
            usually four form characters can stick to previous and next character, two form characters can stick to previous and not to next character.
            </remarks>
        </member>
        <member name="P:Skill.Text.PersianCharacter.CanStickToNext">
            <summary> Whether this persian character can stick to next character.</summary>
            <remarks>
            usually four form characters can stick to previous and next character, two form characters can stick to previous and not to next character.
            </remarks>
        </member>
        <member name="P:Skill.Text.PersianCharacter.Item(Skill.Text.PersianCharacterForm)">
            <summary> Gets or sets Character in specified form </summary>
            <param name="form">Form of persian character</param>
            <returns>Character in specified form.</returns>
        </member>
        <member name="T:Skill.UI.GridLength">
            <summary>
            Represents the length of elements that explicitly support Skill.UI.GridUnitType.Star unit types.
            </summary>
        </member>
        <member name="M:Skill.UI.GridLength.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the GridLength structure using the specified absolute value in pixels.
            </summary>
            <param name="pixels"> The number of  pixels.</param>
            <exception cref="T:System.ArgumentException">Pixels is equal to float.NegativeInfinity, float.PositiveInfinity, or float.NaN </exception>
        </member>
        <member name="M:Skill.UI.GridLength.#ctor(System.Single,Skill.UI.GridUnitType)">
            <summary>
            Initializes a new instance of the GridLength structure and specifies what kind of value it holds.
            </summary>
            <param name="value"> The initial value of this instance of GridLength. </param>
            <param name="type"> The GridUnitType held by this instance of GridLength. </param>
            <exception cref="T:System.ArgumentException">Pixels is equal to float.NegativeInfinity, float.PositiveInfinity, or float.NaN </exception>
        </member>
        <member name="M:Skill.UI.GridLength.op_Equality(Skill.UI.GridLength,Skill.UI.GridLength)">
            <summary>
             Compares two GridLength structures for equality.
            </summary>
            <param name="gl1"> The first instance of GridLength to compare. </param>
            <param name="gl2"> The second instance of GridLength to compare. </param>
            <returns> true if the two instances of GridLength have the same value and GridUnitType; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.GridLength.op_Inequality(Skill.UI.GridLength,Skill.UI.GridLength)">
            <summary>
             Compares two GridLength structures to determine if they are not equal.
            </summary>
            <param name="gl1"> The first instance of GridLength to compare. </param>
            <param name="gl2"> The second instance of GridLength to compare. </param>
            <returns>true if the two instances of GridLength do not have the same value and GridUnitType; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.GridLength.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current GridLength instance.
            </summary>
            <param name="oCompare"> The object to compare with the current instance. </param>
            <returns> true if the specified object has the same value and GridUnitType as the current instance; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.GridLength.Equals(Skill.UI.GridLength)">
            <summary>
            Determines whether the GridLength is equal to the current GridLength.
            </summary>
            <param name="gridLength"> The GridLength structure to compare with the current instance. </param>
            <returns> true if the specified GridLength has the same value and GridUnitType as the current instance; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.GridLength.GetHashCode">
            <summary>
            Gets a hash code for the GridLength.
            </summary>
            <returns>
             A hash code for the current GridLength structure.
            </returns>
        </member>
        <member name="M:Skill.UI.GridLength.ToString">
            <summary>
            Returns a System.String representation of the GridLength.
            </summary>
            <returns> A System.String representation of the current GridLength structure.</returns>
        </member>
        <member name="P:Skill.UI.GridLength.IsAbsolute">
            <summary>
            Gets a value that indicates whether the GridLength holds a value that is expressed in pixels.
            </summary>
        </member>
        <member name="P:Skill.UI.GridLength.IsAuto">
            <summary>
            Gets a value that indicates whether the GridLength holds a value whose size is determined by the size properties of the content object.
            </summary>
        </member>
        <member name="P:Skill.UI.GridLength.IsStar">
            <summary>
             Gets a value that indicates whether the GridLength holds a value that is expressed as a weighted proportion of available space.
            </summary>
        </member>
        <member name="P:Skill.UI.GridLength.Value">
            <summary>
            Gets a float that represents the value of the GridLength.
            </summary>
        </member>
        <member name="P:Skill.UI.GridLength.GridUnitType">
            <summary>
            Gets the associated GridUnitType for the GridLength.
            </summary>
        </member>
        <member name="P:Skill.UI.GridLength.Auto">
            <summary>
            Gets an instance of GridLength that holds a value whose size is determined by the size properties of the content object.
            </summary>
        </member>
        <member name="T:Skill.Managers.CacheSpawner">
            <summary>
            Manage spawning cache objects
            </summary>
            <remarks>
            Only one instance of this object should be in scene
            </remarks>
        </member>
        <member name="F:Skill.Managers.CacheSpawner.Groups">
            <summary> Groups to manage </summary>
        </member>
        <member name="M:Skill.Managers.CacheSpawner.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Managers.CacheSpawner.Spawn(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,System.Boolean)">
            <summary>
            Spawn a cache object
            </summary>
            <param name="prefab">GameObject with CacheBehavior component</param>
            <param name="position">Position</param>
            <param name="rotation">Rotation</param>
            <param name="enabled">Enable at spawn time or let caller enable it itself</param>
            <returns>Spawned GameObject</returns>
            <remarks>
            If GameObject has not a CacheBehavior component, spawner instantiate it normally ( by GameObject.Instantiate method )
            </remarks>
        </member>
        <member name="M:Skill.Managers.CacheSpawner.DestroyCache(UnityEngine.GameObject)">
            <summary>
            Destroy cache GameObject and add to free list
            </summary>
            <param name="objectToDestroy">GameObject with CacheBehavior component</param>
             /// <remarks>
            If GameObject has not a CacheBehavior component, spawner destroy it normally ( by GameObject.Destroy method )
            </remarks>
        </member>
        <member name="T:Skill.AI.BehaviorContainer">
            <summary>
            Helper class that contains Behavior node and apropriate parameters
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorContainer.#ctor(Skill.AI.Behavior,Skill.AI.BehaviorParameterCollection)">
            <summary>
            Create an instance of BehaviorContainer
            </summary>
            <param name="behavior">Behavior node</param>
            <param name="parameters">Parameters of behavior at this position of tree</param>
        </member>
        <member name="P:Skill.AI.BehaviorContainer.Parameters">
            <summary>
            Parameters of behavior at this position of tree
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorContainer.Behavior">
            <summary>
            Behavior node
            </summary>
        </member>
        <member name="T:Skill.AI.ActionResetEventHandler">
            <summary>
            Represents the method to handle Action reset events.
            </summary>
            <param name="action">Sender behavior</param>        
        </member>
        <member name="T:Skill.AI.ActionHandler">
            <summary>
            Represents the method that will handle execution of action by user
            </summary>    
            <param name="parameters">Parameters for action</param>
            <returns>State of action</returns>
        </member>
        <member name="T:Skill.AI.Action">
            <summary>
            Actions which finally implement an actors or game world state changes, for example to plan a path and move on it, to sense for the nearest enemies,
            to show certain animations, switch weapons, or run a specified sound. Actions will typically coordinate and call into different game systems.
            They might run for one simulation tick – one frame – or might need to be ticked for multiple frames to finish their work.
            Action is leaf node.
            </summary>
        </member>
        <member name="M:Skill.AI.Action.#ctor(System.String,Skill.AI.ActionHandler)">
            <summary>
            Create an instance of Action
            </summary>
            <param name="name">Name of action</param>
            <param name="handler">the function to call at execution time</param>
        </member>
        <member name="M:Skill.AI.Action.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns>Result of action</returns>
        </member>
        <member name="M:Skill.AI.Action.OnReset">
            <summary>
            On Reset
            </summary>        
        </member>
        <member name="M:Skill.AI.Action.ResetBehavior(System.Boolean)">
            <summary>
            Reset behavior. For internal use. when a branch with higher priority executed, let nodes in previous branch reset
            </summary>        
            <param name="resetChildren">Reset children too</param>
        </member>
        <member name="M:Skill.AI.Action.Continue(Skill.AI.BehaviorState)">
            <summary>
            for internal use when behavior tree let action continue (when result is BehaviorResult.Running)
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="E:Skill.AI.Action.Reset">
            <summary>
            Occurs when behavior is reset
            </summary>
        </member>
        <member name="T:Skill.MathHelper">
            <summary>
            Some helper methods for math
            </summary>
        </member>
        <member name="M:Skill.MathHelper.IsAngleLeftOf(System.Single,System.Single)">
            <summary>
            Wether given angle is between (sourceAngle) and (sourceAngle - 180)
            </summary>
            <param name="angle">Angle</param>
            <param name="sourceAngle">Source angle</param>
            <returns>True if angle is left side, otherwise false</returns>
        </member>
        <member name="M:Skill.MathHelper.HorizontalAngle(UnityEngine.Vector3)">
            <summary>
            Calc angle rotation around y axis
            </summary>
            <param name="direction">Direction</param>
            <returns>Angle</returns>
        </member>
        <member name="M:Skill.MathHelper.DeltaAngle(System.Single,System.Single)">
            <summary>
            Calc delta angle base on  0 - 360
            </summary>
            <param name="angle1">Angle 1</param>
            <param name="angle2">Angle 2</param>
            <returns></returns>
        </member>
        <member name="M:Skill.MathHelper.AngleAroundAxis(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            The angle between dirA and dirB around axis
            </summary>
            <param name="dirA">Direction A</param>
            <param name="dirB">Direction B</param>
            <param name="axis">Axis</param>
            <returns>The angle between dirA and dirB around axis</returns>
        </member>
        <member name="M:Skill.MathHelper.MPS_To_KPH(System.Single)">
            <summary>
            Converts 'Meter Per Second' to 'Kilometer Per Hour'
            </summary>
            <param name="mps">value in meter per second</param>
            <returns></returns>
        </member>
        <member name="T:Skill.AI.BehaviorType">
            <summary>
            Defines types of behavior nodes in BehaviorTree
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorType.Composite">
            <summary>
            Contains childeren and execute them in specific order.(none leaf node)
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorType.Condition">
            <summary>
            Check that certain actor or game world states hold true.(leaf node)
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorType.Decorator">
            <summary>
            Typically have only one child and are used to enforce a certain return state 
            or to implement timers to restrict how often the child will run in a given amount of time
            or how often it can be executed without a pause.(none leaf node)
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorType.Action">
            <summary>
            Implement an actors or game world state changes.(leaf node) 
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimNodeBlendByPosture">
            <summary>
            This blend node allows the Anim Tree to automatically blend between three inputs;
            Standing, Crouched and Prone.
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendByPosture.#ctor">
            <summary>
            Create new instance of AnimNodeBlendByPosture
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByPosture.StandingNode">
            <summary> Standing branch </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByPosture.CrouchedNode">
            <summary> Crouched branch </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByPosture.ProneNode">
            <summary> Prone branch </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByPosture.Posture">
            <summary>
            Get or set posture of actor
            </summary>
        </member>
        <member name="T:Skill.AI.FailurePolicy">
            <summary>
            Enumerates the options for when a ConcurrentSelector is considered to have failed.
            </summary>
            <remarks> If FailOnOne and SuceedOnOne are both active and are both trigerred in the same time step, failure will take precedence. </remarks>
        </member>
        <member name="F:Skill.AI.FailurePolicy.FailOnOne">
            <summary>  indicates that the node will return failure as soon as one of its children fails.</summary>
        </member>
        <member name="F:Skill.AI.FailurePolicy.FailOnAll">
            <summary>  indicates that all of the node's children must fail before it returns failure.</summary>
        </member>
        <member name="T:Skill.AI.SuccessPolicy">
            <summary>
            Enumerates the options for when a ConcurrentSelector is considered to have succeeded.
            </summary>    
        </member>
        <member name="F:Skill.AI.SuccessPolicy.SucceedOnOne">
            <summary>
            indicates that the node will return success as soon as one of its children succeeds.
            </summary>
        </member>
        <member name="F:Skill.AI.SuccessPolicy.SucceedOnAll">
            <summary>
            indicates that all of the node's children must succeed before it returns success.
            </summary>
        </member>
        <member name="T:Skill.AI.ConcurrentSelector">
            <summary>
            visit all of their children during each traversal.
            A pre-specified number of children needs to fail to make the concurrent node fail, too.
            Instead of running its child nodes truly in parallel to each other there might be a specific traversal order which can be exploited when adding conditions
            to a concurrent node because an early failing condition prevents its following concurrent siblings from running.
            </summary>
        </member>
        <member name="M:Skill.AI.ConcurrentSelector.#ctor(System.String)">
            <summary>
            Create an instance of ConcurrentSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.AI.ConcurrentSelector.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">state of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="M:Skill.AI.ConcurrentSelector.CheckConditions(Skill.AI.BehaviorState)">
            <summary>
            iterate throw children and evaluate conditions
            </summary>
            <param name="state">State of BehaviorTree</param>
            <returns></returns>
        </member>
        <member name="P:Skill.AI.ConcurrentSelector.FirstConditions">
            <summary> First check for conditions then rest of childs (default true)</summary>
        </member>
        <member name="P:Skill.AI.ConcurrentSelector.BreakOnConditionFailure">
            <summary>
            if true, by first condition failure, ConcurrentSelector returns BehaviorResult.Failure
            </summary>
        </member>
        <member name="P:Skill.AI.ConcurrentSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="P:Skill.AI.ConcurrentSelector.FailurePolicy">
            <summary>
            FailurePolicy (default : FailOnAll)
            </summary>
        </member>
        <member name="P:Skill.AI.ConcurrentSelector.SuccessPolicy">
            <summary>
            SuccessPolicy (default : SucceedOnAll)
            </summary>
        </member>
        <member name="T:Skill.AI.BehaviorParameter">
            <summary>
            Send custom parameter to behaviors
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorParameter.#ctor(System.String,System.Object)">
            <summary>
            Create new instance of BehaviorParameter
            </summary>
            <param name="name">name of parameter</param>
            <param name="value">Value of parameter</param>
        </member>
        <member name="P:Skill.AI.BehaviorParameter.Name">
            <summary>
            Name of parameter
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorParameter.Value">
            <summary>
            Value of parameter
            </summary>
        </member>
        <member name="T:Skill.AI.BehaviorParameterCollection">
            <summary>
            Contains list of parameters
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorParameterCollection.#ctor(Skill.AI.BehaviorParameter[])">
            <summary>
            Create new instance of BehaviorParameterCollection
            </summary>
            <param name="parameters">array od parameters</param>
        </member>
        <member name="M:Skill.AI.BehaviorParameterCollection.GetValue(System.String)">
            <summary>
            Retrieves parameter by name
            </summary>
            <param name="parameterName">Name of parameter</param>
            <returns>Parameter</returns>
        </member>
        <member name="P:Skill.AI.BehaviorParameterCollection.Item(System.String)">
            <summary>
            Retrieves parameter by name
            </summary>
            <param name="parameterName">Name of parameter</param>
            <returns></returns>
        </member>
        <member name="T:Skill.UI.SelectionGridItem">
            <summary>
            An item to show on the grid buttons
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGridItem.OnSelected">
            <summary>
            When item first got selected
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGridItem.OnUnselected">
            <summary>
            When item first time item lost selected
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGridItem.#ctor">
            <summary>
            Create a SelectionGridItem
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGridItem.Content">
            <summary>
            text, image and tooltips for the grid button.
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGridItem.Name">
            <summary> Optional name </summary>
        </member>
        <member name="P:Skill.UI.SelectionGridItem.Index">
            <summary> Index of item in collection</summary>
        </member>
        <member name="P:Skill.UI.SelectionGridItem.IsSelected">
            <summary>
            is item selected
            </summary>
        </member>
        <member name="E:Skill.UI.SelectionGridItem.Selected">
            <summary>
            Occurs When item first got selected
            </summary>
        </member>
        <member name="E:Skill.UI.SelectionGridItem.Unselected">
            <summary>
            Occurs When item first time item lost selected
            </summary>
        </member>
        <member name="T:Skill.UI.SelectionGridItemCollection">
            <summary>
            A collection of SelectionGridItem
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.#ctor">
            <summary>
            Create a SelectionGridItemCollection
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.RefreshContents">
            <summary>
            Meka sure that Contents are valid. call this when change content of an item after add in collection
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.Add(Skill.UI.SelectionGridItem)">
            <summary>
            Adds a SelectionGridItem element to a SelectionGridItemCollection.
            </summary>
            <param name="item">Identifies the SelectionGridItem to add to the collection.</param>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.Clear">
            <summary>
            Clears the content of the SelectionGridItemCollection.
            </summary>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.Contains(Skill.UI.SelectionGridItem)">
            <summary>
            Determines whether a given RowDefinition exists within a SelectionGridItemCollection.
            </summary>
            <param name="item"> Identifies the SelectionGridItem that is being tested. </param>
            <returns>true if the SelectionGridItem exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.CopyTo(Skill.UI.SelectionGridItem[],System.Int32)">
            <summary>
             Copies an array of SelectionGridItem objects to a given index position within a SelectionGridItemCollection.
            </summary>
            <param name="array"> An array of SelectionGridItem objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the SelectionGridItem objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.Remove(Skill.UI.SelectionGridItem)">
            <summary>
            Removes a SelectionGridItem from a SelectionGridItemCollection.
            </summary>
            <param name="item"> The SelectionGridItem to remove from the collection. </param>
            <returns> true if the SelectionGridItem was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltSelectionGridItem;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="M:Skill.UI.SelectionGridItemCollection.IndexOf(Skill.UI.SelectionGridItem)">
            <summary>
            return first occurence index of specified SelectionGridItem
            </summary>
            <param name="item">item to find</param>
            <returns>
            > 0 index of SelectionGridItem; otherwise -1.
            </returns>
        </member>
        <member name="P:Skill.UI.SelectionGridItemCollection.Contents">
            <summary>
            Array of item's contents
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGridItemCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a SelectionGridItemCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="P:Skill.UI.SelectionGridItemCollection.Count">
            <summary>
            Gets the total number of items within this instance of SelectionGridItemCollection.
            </summary>
        </member>
        <member name="P:Skill.UI.SelectionGridItemCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a SelectionGridItemCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.UI.SelectionMode">
            <summary> Defines the selection behavior for a ListBox. </summary>
        </member>
        <member name="F:Skill.UI.SelectionMode.Single">
            <summary> The user can select only one item at a time. </summary>
        </member>
        <member name="F:Skill.UI.SelectionMode.Multiple">
            <summary> The user can select multiple items without holding down a modifier key. </summary>
        </member>
        <member name="F:Skill.UI.SelectionMode.Extended">
            <summary> The user can select multiple consecutive items while holding down the SHIFT key. </summary>
        </member>
        <member name="T:Skill.UI.ListBox">
            <summary>
            Contains a list of selectable items.
            </summary>
        </member>
        <member name="M:Skill.UI.ListBox.OnSelectionChanged">
            <summary>
            when the selection of ListBox changes.
            </summary>
        </member>
        <member name="M:Skill.UI.ListBox.#ctor">
            <summary>
            Create an instance of ScrollView
            </summary>
        </member>
        <member name="M:Skill.UI.ListBox.BeginRender">
            <summary> Begin render control's content </summary>
        </member>
        <member name="M:Skill.UI.ListBox.Render">
            <summary>
            Render ListBox
            </summary>
        </member>
        <member name="M:Skill.UI.ListBox.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="P:Skill.UI.ListBox.SelectedItems">
            <summary> Gets the currently selected items. </summary>
            <returns> Returns a collection of the currently selected items. </returns>
            <exception cref="T:System.InvalidOperationException"> The ListBox.SelectionMode property is set to SelectionMode.Single. </exception>
        </member>
        <member name="P:Skill.UI.ListBox.SelectedItem">
            <summary> Gets or sets the first item in the current selection or returns null if the selection is empty </summary>
            <returns>The first item in the current selection or null if the selection is empty.</returns>
        </member>
        <member name="P:Skill.UI.ListBox.SelectedIndex">
            <summary> 
            Gets or sets the index of the first item in the current selection or returns
            negative one (-1) if the selection is empty.
            </summary>
            <returns>
            The index of first item in the current selection. The default value is negative one (-1).
            </returns>
        </member>
        <member name="P:Skill.UI.ListBox.SelectionMode">
            <summary>
            Gets or sets the selection behavior for a ListBox.
            </summary>
            <returns>One of the SelectionMode values. The default is SelectionMode.Single selection.</returns>
        </member>
        <member name="E:Skill.UI.ListBox.SelectionChanged">
            <summary>
            Occurs when the selection of ListBox changes.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.SelectedStyle">
            <summary>
            Style to use for Box used for background of selected items
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.Background">
            <summary>
            Border and Background.
            </summary>
            <remarks>
            To draw border and background if ListBox set visibility of Background property to true and set valid style
            </remarks>
        </member>
        <member name="P:Skill.UI.ListBox.HorizontalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.VerticalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.ScrollPosition">
            <summary>
            The pixel distance that the view is scrolled in the X and Y directions.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.ScrollX">
            <summary>
            The pixel distance that the view is scrolled in the X direction.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.ScrollY">
            <summary>
            The pixel distance that the view is scrolled in the Y direction.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.AlwayShowHorizontal">
            <summary>
            Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when clientRect is wider than position.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.AlwayShowVertical">
            <summary>
            Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when clientRect is taller than position.
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.HandleScrollWheel">
            <summary>
            Optional parameter to handle ScrollWheel
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.ScrollViewRect">
            <summary>
            Gets view rectangle used for inner ScrollView
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.ScrollbarThickness">
            <summary>
            Gets or sets thikness of vertical scrollbar to consider when calculating scrollview area (default is 16)
            </summary>
        </member>
        <member name="P:Skill.UI.ListBox.Padding">
            <summary>
            Gets or sets the padding inside a control.
            </summary>
            <returns>
            The amount of space between the content of a Panel
            and its Margin or Border.
            The default is a thickness of 0 on all four sides.
            </returns>
        </member>
        <member name="T:Skill.Animation.AnimNodeBlendByIdle">
            <summary>
            This node automatically blends between idle and moving depending on the velocity.
            If the owner's velocity is zero (or a relatively small number) then the node blend to the 'Idle' branch.
            Otherwise the node blends to the 'Moving' branch.
            http://udn.epicgames.com/Three/AnimationNodes.html#UDKAnimBlendByIdle / _UTAnimBlendByIdle
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendByIdle.CalcBlendWeights(System.Single[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>
        </member>
        <member name="M:Skill.Animation.AnimNodeBlendByIdle.#ctor">
            <summary>
            Create new instance of AnimNodeBlendByIdle
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIdle.IdleNode">
            <summary>
            Idle branch
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIdle.MovingNode">
            <summary>
            Moving branch
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIdle.IdleWeight">
            <summary>
            Weight of idle branch
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIdle.IsIdle">
            <summary>
            Whether actor is idle?
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimNodeBlendByIdle.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="T:Skill.AI.BehaviorState">
            <summary>
            Represent State of behaviorTree and send data between nodes
            </summary>
        </member>
        <member name="F:Skill.AI.BehaviorState.MaxSequenceLength">
            <summary>
            Maximum lenght of visited behaviors in each BehaviorTree update
            if your BehaviorTrees is very large increas this value
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorState.#ctor">
            <summary>
            Create a BehaviorState
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorState.Begin">
            <summary>
            BehaviorTree call this method at begin of each update (internal use)
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorState.RegisterForExecution(Skill.AI.Behavior)">
            <summary>
            each behavior before execution call this method to register in execution sequence.
            </summary>
            <param name="behavior">Behavior to register</param>
            <returns>Return registerd index</returns>
            <remarks>
            we need to keep last execution sequenece to aviod some mistakes in tree
            for example : at LimitAccessDecoratot execution, it must get access to key
            if the result be Running then it hold the key until next update (at least)
            if in next update a branch before that be executed we lost the key and never unlock it        
            </remarks>
        </member>
        <member name="M:Skill.AI.BehaviorState.UnRegisterForExecution(Skill.AI.Behavior)">
            <summary>
            Unregister behavior from execution sequence.
            </summary>
            <param name="behavior">Behavior to unregister</param>
        </member>
        <member name="M:Skill.AI.BehaviorState.LogExecutionSequence">
            <summary>
            Write ExecutionSequence to UnityEngin.Debug.Log
            </summary>
        </member>
        <member name="M:Skill.AI.BehaviorState.LogExecutionSequenceTree">
            <summary>
            Write ExecutionSequence to UnityEngin.Debug.Log in tree style
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorState.Parameters">
            <summary>
            Used internally to send valid parameters to child behaviors
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorState.Exception">
            <summary>
            exception occurs in evaluation of tree, otherwise null
            </summary>
        </member>
        <member name="P:Skill.AI.BehaviorState.RunningActions">
            <summary>
            current running actions.
            </summary>
            <remarks>
            action is allways leaf node. after execution of each action, if result is running hold it's reference
            </remarks>
        </member>
        <member name="P:Skill.AI.BehaviorState.ExecutionSequence">
            <summary>
            The execution sequence after last update call.
            </summary>
            <remarks>
            This Property is for additional info and debug, do not modify this manually.
            </remarks>
        </member>
        <member name="P:Skill.AI.BehaviorState.SequenceCount">
            <summary> Number of valid Behaviors in ExecutionSequence</summary>
        </member>
        <member name="T:Skill.Controllers.Spawner">
            <summary>
            Use this class to spawn object in scheduled time and with triggers
            </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.SpawnObject">
            <summary> GameObject to spawn </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.SpawnLocations">
            <summary> where to spawn objects </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.CycleSpawnLocations">
            <summary> If true, the spawner will cycle through the spawn locations instead of spawning from a randomly chosen one </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.SpawnInterval">
            <summary> Delta time between spawns </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.AliveCount">
            <summary> The maximum number of agents alive at one time. If agents are destroyed, more will spawn to meet this number. </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.MaxSpawnCount">
            <summary> The maximum number of agents to spawn.when number of spawned object reach this value the spawner will not spawn anymore  </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.RespawnDeadAgents">
            <summary> If true, agents that are totally removed (ie blown up) are respawned </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.SpawnRadius">
            <summary> Radius around spawn location to spawn agents. </summary>
        </member>
        <member name="F:Skill.Controllers.Spawner.SpawnOnAwake">
            <summary> Spawn On Awake </summary>
        </member>
        <member name="M:Skill.Controllers.Spawner.InitializeSpawnedObject(UnityEngine.GameObject)">
            <summary>
            let inherited class modify spawned object right after spawn time
            </summary>
            <param name="spawnedObj">Spawned Object</param>
        </member>
        <member name="M:Skill.Controllers.Spawner.OnComplete">
            <summary>
            when spawner spawned all objects
            </summary>
        </member>
        <member name="M:Skill.Controllers.Spawner.Spawn">
            <summary>
            Spawn new game objects
            </summary>
        </member>
        <member name="M:Skill.Controllers.Spawner.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Controllers.Spawner.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Controllers.Spawner.OnDestroy">
            <summary>
            when spawner destroyed (all spawned objects will destroyed too)
            </summary>
        </member>
        <member name="M:Skill.Controllers.Spawner.DestroySpawnedObject(UnityEngine.GameObject)">
            <summary>
            Destroy Spawned Object by this spawner
            </summary>
            <param name="spawnedObj">GameObject or destroy</param>
        </member>
        <member name="M:Skill.Controllers.Spawner.OnDieSpawnedObject(UnityEngine.GameObject)">
            <summary>
            Notify spawner that given object is dead but not destroyed yet ( the dead body is still visible )
            </summary>
            <param name="deadSpawnedObj">dead spawned object</param>
        </member>
        <member name="P:Skill.Controllers.Spawner.DisableAfterAll">
            <summary> Spawner will disabled when (number of spawned object) reach MaxSpawnCount, in other words, when spawned all objects. </summary>
        </member>
        <member name="P:Skill.Controllers.Spawner.SpawnedObjects">
            <summary> List of all alive spawned objects </summary>
        </member>
        <member name="P:Skill.Controllers.Spawner.CanSpawn">
            <summary>
            Subclasses can avoid spawning for some reason at specific times
            </summary>
        </member>
        <member name="E:Skill.Controllers.Spawner.Complete">
            <summary>
            Occurs when spawner spawned all objects
            </summary>
        </member>
        <member name="T:Skill.UI.VerticalAlignment">
            <summary>
            Describes how a child element is vertically positioned or stretched within a parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.UI.VerticalAlignment.Top">
            <summary>
            The child element is aligned to the top of the parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.UI.VerticalAlignment.Center">
            <summary>
            The child element is aligned to the center of the parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.UI.VerticalAlignment.Bottom">
            <summary>
            The child element is aligned to the bottom of the parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.UI.VerticalAlignment.Stretch">
            <summary>
            The child element stretches to fill the parent's layout slot.
            </summary>
        </member>
        <member name="T:Skill.UI.Dock">
            <summary>
            Specifies the Dock position of a child element that  is inside a DockPanel.
            </summary>
        </member>
        <member name="F:Skill.UI.Dock.Left">
            <summary>
            A child element that is positioned on the left side of the DockPanel.
            </summary>
        </member>
        <member name="F:Skill.UI.Dock.Top">
            <summary>
            A child element that is positioned at the top of the DockPanel.
            </summary>
        </member>
        <member name="F:Skill.UI.Dock.Right">
            <summary>
            A child element that is positioned on the right side of the DockPanel.
            </summary>
        </member>
        <member name="F:Skill.UI.Dock.Bottom">
            <summary>
            A child element that is positioned at the bottom of the DockPanel.
            </summary>
        </member>
        <member name="T:Skill.UI.DockPanel">
            <summary>
            Defines an area where you can arrange child elements either horizontally or vertically, relative to each other.
            </summary>
        </member>
        <member name="M:Skill.UI.DockPanel.#ctor">
            <summary>
            Initializes a new instance of the DockPanel class.
            </summary>
        </member>
        <member name="M:Skill.UI.DockPanel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.UI.DockPanel.LastChildFill">
            <summary>
            Gets or sets a value that indicates whether the last child element within
            a DockPanel stretches to fill the remaining available space. (The default value is true.)
            </summary>
        </member>
        <member name="T:Skill.AI.IRandomService">
            <summary>
            Defines an interface for objects that can generate random values 
            </summary>
        </member>
        <member name="M:Skill.AI.IRandomService.Range(System.Single,System.Single)">
            <summary>
            Returns a random float number between and min [inclusive] and max [inclusive].
            </summary>
            <param name="min">min value</param>
            <param name="max">max value</param>
            <returns>a random float number between and min [inclusive] and max [inclusive].</returns>
        </member>
        <member name="T:Skill.AI.RandomSelector">
            <summary>    
            Select random child by chance for execution and continue executing that until result of chlid be Running. 
            if result is Failure or success, selected another random child on next exevution
            </summary>
        </member>
        <member name="M:Skill.AI.RandomSelector.#ctor(System.String)">
            <summary>
            Create an instance of RandomSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.AI.RandomSelector.Add(Skill.AI.Behavior,Skill.AI.BehaviorParameterCollection)">
            <summary>
            Add child . Remember to set weight of child before call this function
            </summary>
            <param name="child"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Skill.AI.RandomSelector.RemoveAll">
            <summary>
            Remove all children
            </summary>
        </member>
        <member name="M:Skill.AI.RandomSelector.Remove(Skill.AI.Behavior)">
            <summary>
            Remove specified child from children
            </summary>
            <param name="child">behavior child to remove</param>
            <returns>true for success, otherwise false</returns>
        </member>
        <member name="M:Skill.AI.RandomSelector.Behave(Skill.AI.BehaviorState)">
            <summary>
            Behave
            </summary>
            <param name="state">State od BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="M:Skill.AI.RandomSelector.GetRandomIndex">
            <summary>
            Select random child by chance
            </summary>
            <returns>Index of selected child</returns>
        </member>
        <member name="P:Skill.AI.RandomSelector.RandomService">
            <summary>        
            Gets or sets random value generation service
            </summary>
            <remarks>
            The main reason to write this property is :
            as for simulation BehaviorTree in Skill Studio i use Skill Dll, to avoid writing duplicate code for BehaviorTree (one in Skill Dll and one in Skill Studio)
            i could't use UnityEngine.Random class in Skill Studio application. so i create IRandomService interface to change random generation
            algorithm in Skill Studio application. Although you can change random generation algorith (:D).
            </remarks>
        </member>
        <member name="P:Skill.AI.RandomSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="T:Skill.Animation.AnimationTreeState">
            <summary>
            Contains data to send throw AnimNodes at update
            </summary>
        </member>
        <member name="M:Skill.Animation.AnimationTreeState.#ctor(Skill.Animation.AnimationTree)">
            <summary>
            Create an instance of AnimationTreeState
            </summary>
            <param name="tree">AnimationTree</param>
        </member>
        <member name="P:Skill.Animation.AnimationTreeState.Tree">
            <summary>
            AnimationTree
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationTreeState.Controller">
            <summary>
            The updating controller
            </summary>
        </member>
        <member name="P:Skill.Animation.AnimationTreeState.ForceUpdate">
            <summary> Force update AnimationTree first time </summary>
        </member>
        <member name="T:Skill.UI.ToolbarButton">
            <summary>
            item to show on the toolbar buttons.
            </summary>
        </member>
        <member name="M:Skill.UI.ToolbarButton.OnSelected">
            <summary>
            Occurs When item first got selected
            </summary>
        </member>
        <member name="M:Skill.UI.ToolbarButton.OnUnselected">
            <summary>
            Occurs When item first time item lost selected
            </summary>
        </member>
        <member name="M:Skill.UI.ToolbarButton.#ctor">
            <summary>
            Create a ToolbarButton
            </summary>
        </member>
        <member name="P:Skill.UI.ToolbarButton.Content">
            <summary>
             text, image and tooltip for the toolbar button.
            </summary>
        </member>
        <member name="P:Skill.UI.ToolbarButton.Index">
            <summary> Index of button </summary>
        </member>
        <member name="P:Skill.UI.ToolbarButton.Name">
            <summary>
            Optional name for button
            </summary>
        </member>
        <member name="P:Skill.UI.ToolbarButton.IsSelected">
            <summary>
            is button selected
            </summary>
        </member>
        <member name="E:Skill.UI.ToolbarButton.Selected">
            <summary>
            Occurs When item first got selected
            </summary>
        </member>
        <member name="E:Skill.UI.ToolbarButton.Unselected">
            <summary>
            Occurs When item first time item lost selected
            </summary>
        </member>
        <member name="T:Skill.UI.ToolbarButtonCollection">
            <summary>
            A collection of ToolbarButton
            </summary>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.#ctor">
            <summary>
            Create a ToolbarButtonCollection
            </summary>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.RefreshContents">
            <summary>
            Meka sure that Contents are valid. call this when change content of an item after add in collection
            </summary>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.Add(Skill.UI.ToolbarButton)">
            <summary>
            Adds a ToolbarButton element to a ToolbarButtonCollection.
            </summary>
            <param name="item">Identifies the ToolbarButton to add to the collection.</param>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.Clear">
            <summary>
            Clears the content of the ToolbarButtonCollection.
            </summary>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.Contains(Skill.UI.ToolbarButton)">
            <summary>
            Determines whether a given RowDefinition exists within a ToolbarButtonCollection.
            </summary>
            <param name="item"> Identifies the ToolbarButton that is being tested. </param>
            <returns>true if the ToolbarButton exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.CopyTo(Skill.UI.ToolbarButton[],System.Int32)">
            <summary>
             Copies an array of ToolbarButton objects to a given index position within a ToolbarButtonCollection.
            </summary>
            <param name="array"> An array of ToolbarButton objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the ToolbarButton objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.Remove(Skill.UI.ToolbarButton)">
            <summary>
            Removes a ToolbarButton from a ToolbarButtonCollection.
            </summary>
            <param name="item"> The ToolbarButton to remove from the collection. </param>
            <returns> true if the ToolbarButton was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltToolbarButton;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="M:Skill.UI.ToolbarButtonCollection.IndexOf(Skill.UI.ToolbarButton)">
            <summary>
            return first occurence index of specified ToolbarButton
            </summary>
            <param name="item">item to find</param>
            <returns>
            > 0 index of ToolbarButton; otherwise -1.
            </returns>
        </member>
        <member name="P:Skill.UI.ToolbarButtonCollection.Contents">
            <summary>
            Array of item's contents
            </summary>
        </member>
        <member name="P:Skill.UI.ToolbarButtonCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a ToolbarButtonCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="P:Skill.UI.ToolbarButtonCollection.Count">
            <summary>
            Gets the total number of items within this instance of ToolbarButtonCollection.
            </summary>
        </member>
        <member name="P:Skill.UI.ToolbarButtonCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a ToolbarButtonCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.UI.Slider">
            <summary> A slider the user can drag to change a value between a min and a max. </summary>
        </member>
        <member name="M:Skill.UI.Slider.OnValueChanged">
            <summary>
            Occurs when value of slider changed
            </summary>
        </member>
        <member name="M:Skill.UI.Slider.#ctor">
            <summary>
            Create an instance of Slider
            </summary>
        </member>
        <member name="M:Skill.UI.Slider.Render">
            <summary>
            Render Slider
            </summary>
        </member>
        <member name="P:Skill.UI.Slider.ThumbStyle">
            <summary>
            The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.UI.Slider.Orientation">
            <summary>
            Orientation of slider
            </summary>
        </member>
        <member name="P:Skill.UI.Slider.Value">
            <summary>
            The value the slider shows. This determines the position of the draggable thumb.
            </summary>
        </member>
        <member name="E:Skill.UI.Slider.ValueChanged">
            <summary>
            Occurs when value of slider changed
            </summary>
        </member>
        <member name="P:Skill.UI.Slider.MinValue">
            <summary>
            Minimum valud of slider
            </summary>
        </member>
        <member name="P:Skill.UI.Slider.MaxValue">
            <summary>
            Maximum valud of slider
            </summary>
        </member>
        <member name="T:Skill.UI.Orientation">
            <summary>
            Defines the different orientations that a control or layout can have.
            </summary>
        </member>
        <member name="F:Skill.UI.Orientation.Horizontal">
            <summary>
            Control or layout should be horizontally oriented.
            </summary>
        </member>
        <member name="F:Skill.UI.Orientation.Vertical">
            <summary>
            Control or layout should be vertically oriented.
            </summary>
        </member>
        <member name="T:Skill.UI.Button">
            <summary>
            Make a single press button. The user clicks them and something happens immediately.
            </summary>
        </member>
        <member name="M:Skill.UI.Button.OnClick">
            <summary>
            when users clicks the button
            </summary>
        </member>
        <member name="M:Skill.UI.Button.#ctor">
            <summary>
            Create a Button
            </summary>
        </member>
        <member name="M:Skill.UI.Button.Render">
            <summary>
            Render button
            </summary>
        </member>
        <member name="P:Skill.UI.Button.Content">
            <summary>
            Text, image and tooltip for this button.
            </summary>
        </member>
        <member name="E:Skill.UI.Button.Click">
            <summary>
            Occurs when users clicks the button
            </summary>
        </member>
        <member name="T:Skill.UI.Box">
            <summary>
            Make a graphical box.
            </summary>
        </member>
        <member name="M:Skill.UI.Box.#ctor">
            <summary>
            Make a graphical box.
            </summary>
        </member>
        <member name="M:Skill.UI.Box.Render">
            <summary> Render box content </summary>
        </member>
        <member name="P:Skill.UI.Box.Content">
            <summary>
            Text, image and tooltip for this box.
            </summary>
        </member>
        <member name="T:Skill.Text.PersianTextConverter">
            <summary>
            Convert a text contains of none persian characters to equivalent persian characters.
            </summary>
            <remarks>
            this version of converter does not care about changes of text and use light calculation to convert text.
            use this class when you want convert static texts, or when your TextField is RightToLeft (currently unity does not support RTL TextFields)
            </remarks>
        </member>
        <member name="M:Skill.Text.PersianTextConverter.#ctor(Skill.Text.IPersianCharacterMap,System.Int32)">
            <summary>
            Create a PersianTextConverter
            </summary>
            <param name="characterMap">Character mapping information for persian language</param>
            <param name="maxLength">Maximum length of text ( for better performance)</param>
        </member>
        <member name="M:Skill.Text.PersianTextConverter.Convert(System.String)">
            <summary>
            Convert specified text to equivalent persian text
            </summary>
            <param name="text">Text to convert</param>
            <returns>Converted text</returns>
        </member>
        <member name="P:Skill.Text.PersianTextConverter.CharacterMap">
            <summary>
            IPersianCharacterMap provided for this converter
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextConverter.MaxLength">
            <summary>
            Maximum length of text ( for better performance)
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextConverter.LastConvertedText">
            <summary>
            Retrieves last converted text by this converter
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextConverter.RightToLeft">
            <summary>
            if your TextField is right to left set this parameter to true
            </summary>
            <remarks>
            Unity currently does not support right to left TextField, so to convert text in LTR format to RTL persian format
            we have to reverse text.
            </remarks>
        </member>
        <member name="P:Skill.Text.PersianTextConverter.ConvertLigature">
            <summary>
            Whether convert لا and الله to one equivalent character. (default true)
            </summary>
        </member>
        <member name="P:Skill.Text.PersianTextConverter.TextToSave">
            <summary>
            if converter is LTR This is reversed text to save.
            </summary>
            <remarks>
            When we set text of TextField for first time the converter does not know that this text reversed before
            so (if converter is LTR) it will reverse it and the result in TextFiled gets wrong.
            </remarks>
        </member>
        <member name="T:Skill.Managers.CacheBehavior">
            <summary>
            Behavior that required for a Cacheable object
            </summary>
        </member>
        <member name="P:Skill.Managers.CacheBehavior.CacheId">
            <summary> Unique id for all instance of this object </summary>
        </member>
        <member name="P:Skill.Managers.CacheBehavior.IsCollected">
            <summary> whether this object collected by CacheSpawner or not </summary>
        </member>
        <member name="P:Skill.Managers.CacheBehavior.Group">
            <summary> Group </summary>
        </member>
        <member name="T:Skill.AI.RunningStack">
            <summary>
            Defines a stack that contains last running behaviors sequence
            </summary>
        </member>
        <member name="M:Skill.AI.RunningStack.#ctor(Skill.AI.BehaviorState,System.Int32)">
            <summary>
            Create an instance of RunningStack
            </summary>        
            <param name="state"> State of Behavior</param>
            <param name="length">Maximum lenght of stack</param>
        </member>
        <member name="M:Skill.AI.RunningStack.Push(Skill.AI.Behavior)">
            <summary>
            Push new behavior to stack
            </summary>
            <param name="b">Behavior to push</param>
        </member>
        <member name="M:Skill.AI.RunningStack.Pop">
            <summary>
            Pop a Behavior from stack
            </summary>
            <returns>Popped Behavior</returns>
        </member>
        <member name="M:Skill.AI.RunningStack.Swap">
            <summary>
            Swap current stack with previous stack and prepare for new update
            </summary>
        </member>
        <member name="M:Skill.AI.RunningStack.ResetPreviousStack">
            <summary>
            Call Reset behavior for running behaviors in previous stack
            </summary>
        </member>
        <member name="M:Skill.AI.RunningStack.ResetStack(Skill.AI.Behavior[],Skill.AI.Behavior[])">
            <summary>
            Reset previous stack
            </summary>
            <param name="current">Current stack</param>
            <param name="previous">Previous stack</param>
        </member>
        <member name="P:Skill.AI.RunningStack.Top">
            <summary>
            Retrieves top of the stack
            </summary>
        </member>
    </members>
</doc>
